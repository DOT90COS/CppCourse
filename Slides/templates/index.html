<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Templates</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="CSS/course.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="templates">Templates</h1><h2 id="building-programs-that-the-compiler-runs">Building programs that the compiler runs!</h2><img src="images/Templates.png"></img></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="id1">Templates</h1><p>Templates are how we achieve generic programming in C++.</p><ul><li>Templates allow a straightforward way to represent a wide range of general concepts and simple ways to combine them.</li><li>The template mechanism allows a type or a value to be a parameter in the definition of a class, a function, or a type alias.</li><li>Every major standard-library abstraction is represented as a template<ul><li>ostream, list, map, unique_ptr, function, ...</li></ul></li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="defining-a-template">Defining a template</h1><p>As a function:</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">foo</span><span class="p">(</span> <span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="as-a-class">As a class</h1><ul><li>A class generated from a template is an ordinary class</li><li>There is no run-time mechanism or overhead</li></ul><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
    <span class="n">T</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="n">array_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
      <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span></pre></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="instantiation-of-templates">Instantiation of Templates</h1><p>For classes we almost always supply template arguments.</p><pre class="highlight code C++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; string;</span></pre><p>For functions we sometimes supply template arguments.</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">to</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">num</span><span class="p">;</span>
    <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">num1</span><span class="p">,</span> <span class="n">T</span> <span class="n">num2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">num</span> <span class="o">=</span> <span class="n">to</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"924"</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"924"</span><span class="p">,</span> <span class="s">"is a number"</span><span class="p">);</span> <span class="c1">//Even tho is isn't required we can still provide the arguments.</span></pre></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="type-equivalence">Type Equivalence</h1><p>It is important to understand how templates view types because for every new type use the compiler will generate a new version.</p><ul><li>Aliases do not introduce a new type</li></ul><pre class="highlight code C++"><span class="k">using</span> <span class="n">uint</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//same type as a.</span></pre><ul><li>Unsigned v. signed ARE different types.</li><li>The compiler can evaluate constexpr (constant expressions)<blockquote><ul><li>so <tt>Buffer&lt;char, 20-10&gt;</tt> will be the same type as <tt>Buffer&lt;char, 10&gt;</tt></li></ul></blockquote></li><li>Types generated by a single template with different arguments are different types.</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="errors">Errors</h1><p>Errors relating to template parameters cannot be detected until the template is used.</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Elem</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elem</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">container</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecInt</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">push_back</span><span class="p">(</span><span class="n">vecInt</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">//FINE.
</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">//ERROR "left of .push_back must have class/struct/union"</span></pre></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="type-checking">Type Checking</h1><p>There is currently no way to implement requirements on template parameters.</p><pre class="highlight code C++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">Container</span> <span class="n">Cont</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Elem</span><span class="o">&gt;</span>
    <span class="n">requires</span> <span class="n">Equal_comparable</span><span class="o">&lt;</span><span class="n">Cont</span><span class="o">::</span><span class="n">value_type</span><span class="p">,</span> <span class="n">Elem</span><span class="o">&gt;</span><span class="p">()</span>
<span class="kt">int</span> <span class="n">find_index</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Elem</span> <span class="n">e</span><span class="p">);</span></pre><ul><li>This is the idea behind the concepts proposal that hasn't made it into the standard yet.</li></ul></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="static-assert">static_assert</h1><p>static_assert allowing for better error messages.</p><ul><li>static_assert is a compile time assert.</li><li>if false the message in the assert will appear as a compiler error</li></ul><pre class="highlight code">template&lt;typename Cont, typename Elem&gt;
void push_back(Cont&amp; container, const Elem&amp; elem)
{
    static_assert(std::is_class&lt;Cont&gt;::value, "Cont must be a class");
    container.push_back(elem);
}

...
push_back(num, 5); //ERROR: Cont must be a class</pre></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="member-templates">Member templates</h1><p>A template or non-template class can have templated member functions.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count_</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="overloading-function-templates">Overloading Function Templates</h1><ul><li>overload resolution will be needed to deduce the proper function call</li><li>The most specialize function will be called.</li></ul><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">foo</span><span class="p">(</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element2</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">foo</span><span class="p">(</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">elem2</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">element1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">elem2</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">elem1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">elem2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FooBar</span><span class="o">&gt;</span> <span class="n">foobars</span><span class="p">;</span>
<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//int foo(int, int);
</span><span class="n">foo</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//T foo(const T&amp;, int);
</span><span class="n">foo</span><span class="p">(</span><span class="n">foobars</span><span class="p">,</span> <span class="n">FooBar</span><span class="p">());</span> <span class="c1">//std::vector&lt;T&gt; foo(const std::vector&lt;T&gt;&amp;, const T&amp;);
</span><span class="n">foo</span><span class="p">(</span><span class="mf">2.3</span><span class="p">,</span> <span class="mi">2LL</span><span class="p">);</span> <span class="c1">//T foo(const T&amp;, const T&amp;);
</span><span class="n">foo</span><span class="p">(</span><span class="sc">'c'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></pre></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="function-template-deduction">Function template deduction</h1><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">max</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">k</span><span class="p">(){</span>
    <span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//max&lt;int&gt;(1,2)
</span>    <span class="n">max</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">);</span> <span class="c1">//max&lt;char&gt;('a', 'b')
</span>    <span class="n">max</span><span class="p">(</span><span class="mf">2.7</span><span class="p">,</span> <span class="mf">4.9</span><span class="p">);</span> <span class="c1">//max&lt;double&gt;(2.7, 4.9)
</span>    <span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span> <span class="c1">//max&lt;int&gt;(int{s}, 7) (trivial conversion used)
</span>
    <span class="n">max</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//error: ambiguous: max&lt;char, char&gt;() or max&lt;int, int&gt;()?
</span>    <span class="n">max</span><span class="p">(</span><span class="mf">2.7</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//error: ambiguous: max&lt;double, double&gt;() or max&lt;int, int&gt;()?
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="argument-substitution-failure">Argument Substitution Failure.</h1><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">itr</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">itr</span><span class="o">::</span><span class="n">value_type</span> <span class="n">mean</span><span class="p">(</span><span class="n">itr</span> <span class="n">first</span><span class="p">,</span> <span class="n">itr</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">typename</span> <span class="n">itr</span><span class="o">::</span><span class="n">value_type</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">+=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tmp</span> <span class="o">/</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNums</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">arrayNums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span> <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The mean of vecNums is "</span> <span class="o">&lt;&lt;</span> <span class="n">mean</span><span class="p">(</span><span class="n">vecNums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecNums</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">//int* doesn't have a member called value type.
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"the mean of arrayNums is "</span> <span class="o">&lt;&lt;</span> <span class="n">mean</span><span class="p">(</span><span class="n">arrayNums</span><span class="p">,</span> <span class="n">arrayNums</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="sfinae">SFINAE</h1><h2 id="substitution-failure-is-not-an-error">Substitution Failure Is Not An Error</h2><p>In the previous example the call to <tt>mean</tt> with pointers passed in failed because there is no such thing as a <tt>int*::value_type</tt>. However, what if we defined another mean.</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">mean</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">last</span><span class="p">){</span>
    <span class="n">T</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">ptr</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">+=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tmp</span> <span class="o">/</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">);</span>
<span class="p">}</span></pre><p>This works even though the first definition of mean fails. That is because the language has a rule that states that <strong>substitution failure</strong> is not an error. It simply causes that template to be ignored; that is, the template does not contribute a specialization to the overload set.</p><p>Without the SFINAE rule we would get compile-time errors even when error-free alternatives exist.</p></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>