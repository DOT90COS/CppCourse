<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Inheritance</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="CSS/course.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="object-inheritance-and-polymorphism">Object Inheritance and Polymorphism</h1><img src="images/stdExceptions.png"></img><p>Abstraction is a selective ignorance. -- Andrew Koenig</p><div class="notes"><p>The image is taken from The C++ Standard Library: A Tutorial and Reference (2nd Edition).</p></div></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="introduction">Introduction</h1><p>The primary focus of this section is to outline some design techniques, rather than just language features. Designs of class hierarchies can often be a good way of simplifying a complex problem. Computer Science heavily utilizes abstractions to solve real problems and inheritance is one type of abstraction mechanism provided by C++.</p><p>Hierarchies offer two kinds of benefits</p><ul><li>Interface inheritance: Provides a contract that can allow for various types to be derived and access through.</li><li>Implementation inheritance: Simplifies the implementation of derived classes.</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="implementation-of-inheritance">Implementation of Inheritance</h1><pre class="highlight code C++"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">"timepoint.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first_name_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">last_name_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">birthday_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">last_name</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Person</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">setBirthday</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mon</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hour</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getBirthday</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getFirstName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getLastName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="id1">Implementation of Inheritance</h1><pre class="highlight code C++"><span class="cp">#include</span> <span class="cpf">"Person.h"</span><span class="cp">
</span><span class="k">class</span> <span class="nc">Employee</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">Person</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">employeeNumber_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Employee</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="n">employeeNumber</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Employee</span><span class="p">();</span>

    <span class="kt">int</span> <span class="nf">getEmployeeNumber</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">getEmployeeNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="id2">Implementation of Inheritance</h1><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">printPeople</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">person</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Person</span> <span class="n">me</span><span class="p">(</span><span class="s">"Jeff"</span><span class="p">,</span> <span class="s">"Scaparra"</span><span class="p">);</span>
    <span class="n">me</span><span class="p">.</span><span class="n">setBirthday</span><span class="p">(</span><span class="mi">1984</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">34</span><span class="p">);</span>

    <span class="n">printPeople</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>

    <span class="n">Employee</span> <span class="n">aaron</span><span class="p">(</span><span class="s">"Aaron"</span><span class="p">,</span> <span class="s">"Bray"</span><span class="p">,</span> <span class="mi">42</span> <span class="p">);</span>
    <span class="n">aaron</span><span class="p">.</span><span class="n">setBirthday</span><span class="p">(</span><span class="mi">1987</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>

    <span class="n">printPeople</span><span class="p">(</span><span class="n">aaron</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="access-controls">Access Controls</h1><ul><li><em>private</em>: can only be accessed by member functions and friends of the class</li><li><em>protected</em>: can only be acceess by member functions and freidns of the class and of derived classes.</li><li><em>public</em>: its name can be used by any function</li></ul><img src="images/accessControl.png"></img></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="inheritance-types">Inheritance Types</h1><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Employee</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">Person</span>
<span class="p">{</span></pre><ul><li>public</li><li>private</li><li>virtual</li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="is-a-inheritance">Is-A Inheritance</h1><p>Public inheritance is "Is-A" Inheritance. In the previous example:</p><ul><li>an Employee object could be used where a Person was because an Employee is a Person.</li><li>a Person could <em>NOT</em> be used where an Employee was because not all Persons are Employees.</li></ul><p>This sounds simple but can be problematic.</p></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="id3">Is-A Inheritance</h1><p>Can a penguin fly?</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Bird</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span></pre><div class="notes"><p>This example is taken from Item 32 of Effective C++
Now we have a problem. This hierarchy says that penguins can fly, which we know is not true.
There are a few ways to fix this problem</p><ul><li>If your application doesn't need birds to fly (Maybe you only care about beaks and wings) then you can remove fly and get on with your life.</li><li>You could a Bird base class without fly and derive a FlyingBird class from that for flying birds and use the base Bird for non-flying birds.</li><li>You could override fly and have it be a run-time error for Penguin.</li></ul></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="id4">Is-A Inheritance</h1><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Bird</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FlyingBird</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="id5">Is-A Inheritance</h1><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Bird</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">()</span> <span class="p">{</span><span class="n">error</span><span class="p">(</span><span class="s">"Attempt to make a penguin fly!"</span><span class="p">);}</span>
    <span class="p">....</span>
<span class="p">};</span></pre><p>Which way is better?</p><pre class="highlight code C++"><span class="n">Penguin</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">fly</span><span class="p">();</span></pre><div class="notes"><p>C++</p><p>In most cases you should prefer compiler errors over runtime errors.</p></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="virtual">Virtual</h1><p>Virtual functions allow for polymorphism. When we say a function is virtual this means that it can be overridden by a derived class.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::foo</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::bar</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">foobar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foobar::foo</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foobar::bar</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foobar</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">Base</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">Base</span><span class="o">&amp;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="n">a</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span> <span class="c1">//foobar::foo
</span>    <span class="n">b</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span> <span class="c1">//Base::foo
</span>    <span class="n">c</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span> <span class="c1">//Base::foo
</span>    <span class="n">a</span><span class="p">.</span><span class="n">bar</span><span class="p">();</span> <span class="c1">//foobar::bar
</span>    <span class="n">b</span><span class="p">.</span><span class="n">bar</span><span class="p">();</span> <span class="c1">//Base::bar
</span>    <span class="n">c</span><span class="p">.</span><span class="n">bar</span><span class="p">();</span> <span class="c1">//foobar::bar
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="id6">Virtual</h1><ul><li>Functions that <tt>override</tt> a <tt>virtual</tt> function become <tt>virtual</tt> and don't have to be declared <tt>virtual</tt></li><li>To be explicit that your overriding a <tt>virtual</tt> function use the <tt>override</tt> keyword</li><li>To get polymorphic behavior objects must be accessed through a pointer or reference</li><li><tt>virtual</tt> functions work through a virtual function table</li><li>Use <tt>final</tt> to describe a virtual function that shouldn't be <tt>override</tt> by another object.</li></ul><h2 id="use-virtual">Use Virtual</h2><ul><li>When defining and interface</li><li>When we want derived classes to be able to change the function</li></ul></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="override">override</h1><ul><li>Note that override can do multiple things<ul><li>Protects against typos</li><li>Makes it clear that a function is virtual</li><li>Clarifies a programmers intent</li></ul></li><li><tt>override</tt> is not a keyword; it is a contextual keyword<ul><li>Please don't be clever and use override for variable names. This was done for backwards compatibility not for modern use.</li></ul></li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">makeMoney</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//This class should be marked as a defect in a code review.
</span><span class="k">class</span> <span class="nc">foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// A Typo (I forgot it was makeMoney)
</span>  <span class="kt">int</span> <span class="n">getMoney</span><span class="p">();</span> <span class="c1">//This doesn't override makeMoney but the programmer gets no error
</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">bar</span><span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
<span class="kt">int</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//Showing that override can be used elsewhere.
</span><span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">getMoney</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//ERROR!!!
</span>  <span class="c1">//After getting the compiler error I fix the code
</span>  <span class="kt">int</span> <span class="nf">makeMoney</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//clearly shows intent, OK!
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="final">final</h1><p>In the rare case where we inherit from a virtual base class and answer no to:</p><ul><li>Can we imagine the need for further derived classes?</li><li>Does a designer of a derived class need to redefine the function to achieve a plausible aim?</li><li>Is correctly overriding a function straightforward.</li></ul><p>After using final any attempt to override is an error.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">X</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">final</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Y</span> <span class="o">:</span> <span class="k">public</span> <span class="n">X</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//ERROR
</span><span class="p">};</span></pre><ul><li>If the class should never be derived from we can apply the final keyword to the whole class</li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">X</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//overrides and is final
</span><span class="p">};</span></pre><div class="notes"><p>One reason people use final is because of the optimization that it allows the compiler to do in some unique situations. (I.E. passing pointers or references to the Derived Class can be optimized away.)</p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="abstract-class-interface">Abstract Class (Interface)</h1><p>This is another use for virtual where we don't provide a default implementation and these functions are known as pure virtual.</p><h2 id="classes-with-pure-virtual-functions">Classes with pure virtual functions:</h2><ul><li>Cannot be instantiated.</li><li>Can be used as pointers to store derived classes.</li><li>Is how we construct interfaces in C++</li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Slogan</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">slogan</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// A pure virtual function
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Trump</span> <span class="o">:</span> <span class="n">Slogan</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">slogan</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"Make America Great Again!"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Clinton</span> <span class="o">:</span> <span class="n">Slogan</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">slogan</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"Hillary for America"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span></pre><div class="notes"><p>Slogans taken from
* <a href="http://presidential-candidates.insidegov.com/stories/6557/campaign-slogans-presidential-candidate#5-Hillary-Clinton-Democrat">http://presidential-candidates.insidegov.com/stories/6557/campaign-slogans-presidential-candidate#5-Hillary-Clinton-Democrat</a>
* <a href="http://presidential-candidates.insidegov.com/stories/6557/campaign-slogans-presidential-candidate#20-Donald-Trump-Republican">http://presidential-candidates.insidegov.com/stories/6557/campaign-slogans-presidential-candidate#20-Donald-Trump-Republican</a></p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="construction-and-destruction">Construction and Destruction</h1><p>When we derive objects we often want to call the constructors of the base classes.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Base</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">x_</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base DTOR</span><span class="se">\n</span><span class="s">"</span><span class="p">;}</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">y_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Derived</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">Base</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y_</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Base</span> <span class="n">b1</span><span class="p">;</span>
    <span class="n">Derived</span> <span class="n">d1</span><span class="p">;</span>
<span class="p">}</span></pre><div class="notes"><p>Show in VS2015</p></div></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="inheriting-constructors">Inheriting Constructors</h1><p>std::vector doesn't guarantee range checking. If I want to have all the same functionality as std::vector I may do something like:</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Vector</span> <span class="p">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span> <span class="c1">// use vector's size type
</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);}</span> <span class="c1">//use checked access
</span>    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)};</span>
<span class="p">}</span>

<span class="n">Vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="c1">//Error no initializer constructor</span></pre><p>We don't inherit the constructors for Vector this way... :(</p></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="id7">Inheriting Constructors</h1><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Vector</span> <span class="p">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span> <span class="c1">// use vector's size type
</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">vector</span> <span class="c1">//inherit vectors constructors
</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);}</span> <span class="c1">//use checked access
</span>    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)};</span>
<span class="p">}</span>

<span class="n">Vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="c1">//OK uses std::vector initializer-list constructor.</span></pre></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="id8">Inheriting Constructors</h1><p>They can be problematic if you define new member variables that need explicit initialization.</p><pre class="highlight code C++"><span class="k">struct</span> <span class="n">B1</span> <span class="p">{</span>
    <span class="n">B1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">D1</span> <span class="p">:</span> <span class="n">B1</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">B1</span><span class="o">::</span><span class="n">B1</span><span class="p">;</span> <span class="c1">// implicitly declares D1(int)
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//string has a default constructor
</span>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//we "forgot" to provide for initialization of x
</span><span class="p">}</span>

<span class="k">struct</span> <span class="nl">D2</span> <span class="p">:</span> <span class="n">B1</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">B1</span><span class="o">::</span><span class="n">B1</span><span class="p">;</span> <span class="c1">// implicitly declares D1(int)
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//string has a default constructor
</span>    <span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">//x is initialized
</span><span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">D1</span> <span class="n">d1a</span><span class="p">{</span><span class="mi">6</span><span class="p">};</span> <span class="c1">//d1a.x not initialized
</span>    <span class="n">D1</span> <span class="n">d1b</span><span class="p">;</span> <span class="c1">//ERROR no default constructor
</span>    <span class="n">D2</span> <span class="n">d2a</span><span class="p">{</span><span class="mi">6</span><span class="p">};</span> <span class="c1">//ok d2a.x is 0;
</span>    <span class="n">D2</span> <span class="n">d2b</span><span class="p">;</span> <span class="c1">//Still an Error
</span><span class="p">}</span></pre><p>It is usually best to avoid being clever and restrict the use of inheriting constructors to times where you don't add any data members.</p></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="multiple-inheritance">Multiple Inheritance</h1><pre class="highlight code c++"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">eat</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Mammal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">breathe</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">WingedAnimal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">flap</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// A bat is a winged mammal
</span><span class="k">class</span> <span class="nc">Bat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mammal</span><span class="p">,</span> <span class="k">public</span> <span class="n">WingedAnimal</span> <span class="p">{</span>
<span class="p">};</span>

<span class="n">Bat</span> <span class="n">bat</span><span class="p">;</span></pre></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="diamond-pattern">Diamond Pattern</h1><p>The code in the previous slide outlines a problem.
If we want to call bat.eat(); both of of base classes have an eat that they inherited from Animal.
Which do we call?</p><p>We could disambiguate:</p><pre class="highlight code c++"><span class="n">Bat</span> <span class="n">b</span><span class="p">;</span>
<span class="n">Animal</span> <span class="o">&amp;</span><span class="n">mammal</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Mammal</span><span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">Animal</span> <span class="o">&amp;</span><span class="n">winged</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">WingedAnimal</span><span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">mammal</span><span class="p">.</span><span class="n">eat</span><span class="p">();</span>
<span class="n">winged</span><span class="p">.</span><span class="n">eat</span><span class="p">();</span></pre></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="id9">Diamond Pattern</h1><p>A better solution is to use virtual inheritance which will guarantee that we only have one Animal class.</p><pre class="highlight code c++"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">eat</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Mammal</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">breathe</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">WingedAnimal</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">flap</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// A bat is a winged mammal
</span><span class="k">class</span> <span class="nc">Bat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mammal</span><span class="p">,</span> <span class="k">public</span> <span class="n">WingedAnimal</span> <span class="p">{</span>
<span class="p">};</span>

<span class="n">Bat</span> <span class="n">bat</span><span class="p">;</span></pre><p>The animal portion of Bat::WingedAnimal and Bat::Mammal is now the same.</p></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="the-end">The END</h1></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>