<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>STL Containers</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="CSS/course.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="an-overview-of-the-standard-template-library">An Overview of the Standard Template Library</h1><p>The heart of the C++ standard library is the STL.
* Generic library
* Allows users to take advantage of data structures and algorithms without knowing how they work.
* All components are templates</p><h2 id="parts-of-the-stl">Parts of the STL</h2><ul><li><strong>Containers</strong>: Used to manage collections, each container has its own advantages and disadvantages.</li><li><strong>Iterators</strong>: A generic way to step through the containers. Can be thought of as a type of pointer. To advance you <tt>++itr</tt> and to access you <tt>*itr</tt>.</li><li><strong>Algorithms</strong>: Used to process elements of a collection. Algorithms use iterators.</li></ul><dl><dt>In a way, the STL is a departure from object oriented programming:</dt><dd><p>The STL separates the data from the algorithms rather than combining them. In principle, you can combine every kind of container with every kind of algorithm.</p></dd></dl></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="containers">Containers</h1><img src="images/Containers.png" width="700px"></img><ul><li><strong>Sequence Containers</strong>: are <em>ordered collections</em> in which every element has a certain position.</li><li><strong>Associative Containers</strong>: are <em>sorted collections</em> in which the position of an element depends on its value due to a certain sorting criterion. The order of insertion doesn't matter.</li><li><strong>Unordered Containers</strong>: are <em>unordered collections</em> where the only important question is if a specific element is in such a collection.</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="choosing-a-container">Choosing a container</h1><p>When choosing a container we must think about how that container will be used.</p><p>If a container will need to be searched frequently it may be wise to use an associative container that stores the data in sorted order. In this way we can use a binary search.</p><h2 id="on-average">On Average:</h2><table cellpadding="0" cellspacing="0"><thead><tr><th><p><strong>Elements</strong></p></th><th><p><strong>BinSearch</strong></p></th><th><p><strong>Linear Search</strong></p></th></tr></thead><tbody><tr><td><p>1000</p></td><td><p>10</p></td><td><p>500</p></td></tr><tr><td><p>2000</p></td><td><p>11</p></td><td><p>1000</p></td></tr><tr><td><p>16000</p></td><td><p>14</p></td><td><p>8000</p></td></tr></tbody></table><p>This is why it is important that we understand how these algorithms and data structures work.</p></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="big-o-notation">Big-O Notation</h1><table cellpadding="0" cellspacing="0"><thead><tr><th><p>Type</p></th><th><p>Notation</p></th><th><p>Meaning</p></th></tr></thead><tbody><tr><td><p>Constant</p></td><td><p>O(1)</p></td><td><p>The runtime is independent of the number of elements</p></td></tr><tr><td><p>Logarithmic</p></td><td><p>O(log(n))</p></td><td><p>Runtime grows logarithmically with the number of elements</p></td></tr><tr><td><p>Linear</p></td><td><p>O(n)</p></td><td><p>The runtime grows at a linear ratio to n</p></td></tr><tr><td><p>n-log-n</p></td><td><p>O(n*log(n))</p></td><td><p>The runtime grows as a product if linear and log complexity</p></td></tr><tr><td><p>Quadratic</p></td><td><p>O(n^2)</p></td><td><p>The runtime grows quadratically with n</p></td></tr></tbody></table><h2 id="examples">Examples</h2><img src="images/BigO.png" width="700px"></img></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="vectors">Vectors</h1><p><tt>std::vector</tt> maintains an internal array and allows a user to dynamically grow that array at the end of the array.</p><ul><li>allocates an initial capacity that is up to the implementation.<ul><li>We can see the current capacity with .capacity()</li><li>We can set a capacity with .reserve()</li></ul></li><li>if the user grows the capacity greater than a vector can handle the vector class will grow the capacity. (Again how this is done is implementation specific)<ul><li>When the size grows beyond what the vector can hold all items must be copied.</li><li>The cost of this copy is amortized if the increase of capacity is exponential.<ul><li>This means that the cost to push an element back is O(1).</li></ul></li></ul></li><li>if a vector grows very large but then shrinks and likely won't grow that big again you could waste memory.<ul><li>A call to <tt>shrink_to_fit</tt> (C++11) will reduce the memory usage by freeing unused memory.</li></ul></li><li>Inserting elements at the end is fast</li><li>Inserting elements into the middle is slow</li><li>Data is stored contiguously (Good for caching and memcpy)</li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="id1">Vectors</h1><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Create a vector containing integers
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>

    <span class="c1">// Add two more integers to vector
</span>    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>

    <span class="c1">// Iterate and print values of vector
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="deque">Deque</h1><p>Pronounced "deck" and is an abbreviation for "double-ended queue".</p><ul><li>Does not guarantee elements to be contiguous.</li><li>Has quick insertion in the front and back. O(1) amortized</li><li>Slow insertion in the middle. O(n)</li><li>Random access is fast. O(1)</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0U</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>

  <span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="array">Array</h1><ul><li>Useful as a better C-Style Array.</li><li>Fixed size, Can only change the values not the number of elements</li><li>Size must be known at compile time.</li><li>If initialized on the stack the data will be on the stack.</li><li>Basically a light-weight wrapper for C-Arrays</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">25</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Hello"</span><span class="p">,</span> <span class="s">"World"</span><span class="p">};</span>

    <span class="k">for</span><span class="p">(</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="list">List</h1><h2 id="a-doubly-linked-list">A doubly linked list.</h2><ul><li>Random access is slow. O(n)</li><li>Insertion and Removal at any point is fast. O(1)</li><li>Data is not contiguous.</li><li>Direct access using [], or at is not possible (because it would be SLOW).</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">abc</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span> <span class="p">...,</span> <span class="sc">'x'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="sc">'z'</span><span class="p">};</span>

    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">abc</span><span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="forward-list-c-11">forward_list (C++11)</h1><ul><li>Saves memory by only having a pointer to the next element and not the previous</li><li>Has similar performance characteristics as a doubly link list.</li><li><dl><dt>Access to the end is O(n)</dt><dd><ul><li>push_back and size not supported as they would be slow.</li></ul></dd></dl></li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">primes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">17</span><span class="p">};</span>

    <span class="c1">//resize with POOR performance
</span>    <span class="n">primes</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
    <span class="n">prints</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">99</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="nl">elem</span><span class="p">:</span> <span class="n">primes</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="associative-containers">Associative Containers</h1><ul><li>Members of the container are stored sorted</li><li>Finding elements is really fast</li><li>Typically implemented as a type of binary tree</li></ul><h2 id="the-containers">The Containers</h2><ul><li><strong>set</strong> is a collection in which elements are sorted according to their own values.</li><li><strong>multiset</strong> is a collection like the <strong>set</strong> that allows elements to exist more than once.</li><li><strong>map</strong> is a collection of elements with key/value pairs that is sorted based on the key.</li><li><strong>multimap</strong> is a collection like the map that allows elements to be in the collection multiple times.</li></ul></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="set">Set</h1><pre class="highlight code C++"><span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span><span class="n">val_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val_</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">val_</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">getX</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">val_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">setX</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">5</span> <span class="p">};</span> <span class="c1">//Compilation error if X doesn't define operator &lt;
</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="multiset">MultiSet</h1><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">setX</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span> <span class="p">};</span> <span class="c1">//11 is in there twice!
</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="map-and-multimap">Map and Multimap</h1><ul><li>A very useful type.</li><li>Maybe faster than unorder_map if doing a large amount of insertions and removals</li><li>Sorted traversal</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ages</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="s">"Joe"</span><span class="p">,</span> <span class="mi">80</span> <span class="p">},{</span> <span class="s">"Jim"</span><span class="p">,</span> <span class="mi">55</span> <span class="p">},{</span> <span class="s">"Barbra"</span><span class="p">,</span> <span class="mi">34</span> <span class="p">},{</span> <span class="s">"Sara"</span><span class="p">,</span> <span class="mi">38</span> <span class="p">}</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">21</span><span class="p">,</span> <span class="s">"Joe"</span><span class="p">},</span> <span class="p">{</span><span class="mi">21</span><span class="p">,</span> <span class="s">"Jim"</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span> <span class="s">"Barbra"</span><span class="p">},</span> <span class="p">{</span><span class="mi">44</span><span class="p">,</span> <span class="s">"Tim"</span><span class="p">}</span> <span class="p">};</span>

    <span class="n">ages</span><span class="p">[</span><span class="s">"Jamie"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">45</span><span class="p">;</span>
    <span class="n">ages</span><span class="p">[</span><span class="s">"John"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">ages</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">people</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="unordered-containers-c-11">Unordered Containers (C++11)</h1><h2 id="unordered-containers-are-hash-tables">Unordered Containers are Hash Tables!!</h2><ul><li>Great for lookups O(1)!!!</li><li>Amortized constant complexity if using a good hash function</li><li>May use a lot of memory.</li></ul><p>Containers are very similar to associative containers minus the sorted guarantee:</p><ul><li><strong>unordered set</strong>: A collection of unordered elements. Elements may only occur once.</li><li><strong>unordered multiset</strong>: The same as an unordered set but allows duplicates.</li><li><strong>unordered map</strong>: A collection of key/value pairs where the key is only allowed to be in the collection once.</li><li><strong>unordered multimap</strong>: The same a unordered map but allows for duplicate keys.</li></ul></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="iterators">Iterators</h1><p>In C++11 we have range based for loops but sometimes we don't want to iterate one by one through the collection (find for example.)</p><h2 id="iterators-have-the-following-operators">Iterators have the following operators:</h2><ul><li><strong>operator*()</strong> Returns the element at the current position.</li><li><strong>operator++()</strong> Lets the iterator step forward to the next element. Most iterators also allow stepping backward with --.</li><li><strong>operator==()</strong> and <strong>operator!=()</strong> return weather two iterators represent the same position.</li><li><strong>operator=()</strong> Assigns an iterator</li><li>Iterators share an interface but are different types as they need to be specific to the type that they operate over.</li><li>All container classes provide a begin() and end() function to get the first and last iterator</li></ul><img src="images/range-begin-end.svg"></img></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="id2">Iterators</h1><h2 id="an-example">An Example</h2><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">abcs</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span> <span class="p">..</span> <span class="p">,</span> <span class="sc">'x'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="sc">'z'</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">citr</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">citr</span> <span class="o">=</span> <span class="n">abcs</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">citr</span> <span class="o">!=</span> <span class="n">abcs</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">citr</span><span class="p">)</span> <span class="c1">//Here the ++citr matters
</span>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">citr</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ABCS</span><span class="p">(</span><span class="n">abcs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
   <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">abcs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">abcs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ABCS</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="p">});</span>

   <span class="c1">//Got tired of writing loops to print.
</span>   <span class="n">print</span><span class="p">(</span><span class="n">ABCS</span><span class="p">);</span>  <span class="c1">//will print any iterable type. See implementation in VS 2015
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><p>Document may not end with a transition.</p></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>