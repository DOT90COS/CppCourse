<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="CSS/course.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="introduction-cpp">Introduction.cpp</h1><p>&#x201C;C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.&#x201D;
&#x2015; Bjarne Stroustrup</p></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="sylabus-cpp">Sylabus.cpp</h1><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">prerequisites</span><span class="p">())</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">ERROR_NOT_READY</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">expectations</span><span class="p">())</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">ERROR_NOT_MOTIVATED</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">content</span><span class="p">())</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">ERROR_WRONG_CONTENT</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">references</span><span class="p">())</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">ERROR_NEEDS_SAFARI_ACCOUNT</span><span class="p">);</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="2" data-y="800" data-x="1600" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"><pre class="highlight code C++"><span class="kt">bool</span> <span class="nf">prerequisites</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">knowsAnotherLanguage</span><span class="p">();</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="3" data-y="0" data-x="1600" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"></div><div class="step step-level-1" step="4" data-y="1600" data-x="1600" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"><pre class="highlight code C++"><span class="kt">bool</span> <span class="nf">expectations</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">meetsExpectations</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">meetsExpectations</span> <span class="o">=</span> <span class="n">willingToTryNewThings</span><span class="p">()</span> <span class="o">?</span> <span class="nl">meetsExpectations</span> <span class="p">:</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">meetsExpectations</span> <span class="o">=</span> <span class="n">canUseGoogle</span><span class="p">()</span> <span class="o">?</span> <span class="nl">meetsExpectations</span> <span class="p">:</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">meetsExpectations</span> <span class="o">=</span> <span class="n">notExpert</span><span class="p">()</span> <span class="o">?</span> <span class="nl">meetsExpectations</span> <span class="p">:</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">meetsExpectations</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="5" data-y="0" data-x="1600" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"></div><div class="step step-level-1" step="6" data-y="2400" data-x="1600" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"><pre class="highlight code C++"><span class="kt">bool</span> <span class="nf">content</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">hours</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">//8 hours a day, 5 days a week, 3 weeks
</span>  <span class="n">Course</span> <span class="n">cppClass</span><span class="p">(</span><span class="n">hours</span><span class="p">);</span>
  <span class="n">Section</span> <span class="n">fundamentals</span><span class="p">;</span>
  <span class="n">fundamentals</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"History of C++"</span><span class="p">);</span>
  <span class="n">fundamentals</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"The Basics... a refresher"</span><span class="p">)</span>
  <span class="n">fundamentals</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"Types"</span><span class="p">);</span>
  <span class="n">fundamentals</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"User defined types"</span><span class="p">);</span>
  <span class="n">fundamentals</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"Exceptions"</span><span class="p">);</span>
  <span class="n">fundamentals</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"Concrete Classes"</span><span class="p">);</span>
  <span class="n">fundamentals</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"Abstract Classes"</span><span class="p">);</span>
  <span class="n">fundamentals</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"Templates"</span><span class="p">);</span>
  <span class="n">cppClass</span><span class="p">.</span><span class="n">addSection</span><span class="p">(</span><span class="n">fundamentals</span><span class="p">);</span>

  <span class="n">Section</span> <span class="n">stdLib</span><span class="p">;</span>
  <span class="n">stdLib</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"Overview"</span><span class="p">);</span>
  <span class="n">stdLib</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"STL Containers"</span><span class="p">);</span>
  <span class="n">stdLib</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"std::memory"</span><span class="p">);</span>
  <span class="n">stdLib</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"std::string"</span><span class="p">);</span>
  <span class="n">stdLib</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"std::thread"</span><span class="p">);</span>
  <span class="n">stdLib</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"regex"</span><span class="p">)</span>
  <span class="n">cppClass</span><span class="p">.</span><span class="n">addSection</span><span class="p">(</span><span class="n">stdLib</span><span class="p">);</span>

  <span class="n">Section</span> <span class="n">advanced</span><span class="p">;</span>
  <span class="n">advanced</span><span class="p">.</span><span class="n">addLecture</span><span class="p">(</span><span class="s">"Template Metaprogramming by Example"</span><span class="p">);</span>
  <span class="n">advanced</span><span class="p">.</span><span class="n">addProject</span><span class="p">(</span><span class="s">"????"</span><span class="p">)</span>
  <span class="n">cppClass</span><span class="p">.</span><span class="n">addSection</span><span class="p">(</span><span class="n">advanced</span><span class="p">);</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="7" data-y="0" data-x="1600" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"></div><div class="step step-level-1" step="8" data-y="0" data-x="3200" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"><h1 id="gitlab">Gitlab</h1><ul><li>Make sure everyone has an account.</li><li>Course wiki</li><li>Benchmarking Library</li><li>Unit Test Library</li><li>CppCoreGuidelines.</li></ul></div><div class="step step-level-1" step="9" data-y="0" data-x="4800" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"><h1 id="code-of-conduct">Code of Conduct</h1><ul><li>Everyone is expected to do their own work.</li><li>Everyone is expected to not share their work with their neighbor until after an assignment is done.</li><li>If you get code off the internet put a comment in the code saying where you got it.</li><li>Ask Questions!</li><li>My personal books do not leave the classroom (unless it is with me!)</li></ul></div><div class="step step-level-1" step="10" data-y="0" data-x="6400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-z="0"><h1 id="instructor-jeff-scaparra">Instructor: Jeff Scaparra</h1><h2 id="jeff-scaparra-com"><a href="mailto:Jeff@Scaparra.com">Jeff@Scaparra.com</a></h2></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="a-brief-history-of-c">A Brief History of C++</h1><p>&#x201C;There are only two kinds of languages; the ones people complain about and the ones nobody uses.&#x201D;
&#x2015; Bjarne Stroustrup</p><div class="notes"><p>When we take about C++ we have to really specify what iteration of C++ we are talking about.
C++ has changed dramatically over the years and even through recent times. It is important to
understand the evolution of C++ and the state of the standards, libraries, and compilers that
you will depend on to do your jobs. You will find many projects that are built on top of old runtimes
for various reasons. The standard process has be revolutionized and moves quickly now. In this decade
there have been two standards release that dramatically changed the language and there will be one more
with C++17. This is why we have a section on the history of C++.</p></div></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="current-state-of-c">Current State of C++</h1><img src="images/wg21-timeline.png" alt="C++ standards timeline." width="900px"></img></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><img src="images/dennis_richie.gif"></img><p><strong>In 1970 Dennis Ritchie Introduces C</strong></p><dl><dt>Prior to this:</dt><dd><ul><li>Systems programmers were expected to master machine language</li><li>Systems programmers wrote in assembly</li><li>Fortran and Cobol existed for domain specialist not "systems" programming</li></ul></dd><dt>C gave systems programmers:</dt><dd><ul><li>A high level language that was portable.</li><li>Enough control to do most systems programming</li></ul></dd></dl><div class="notes"><p>What were Cobol and Fortran domain languages for?</p><p>COmmon Business Oriented Language - as the expanded acronym indicates, COBOL is designed for
developing business, typically file-oriented, applications.</p><p>Fortran "Formula Translation" - numeric computation and scientific computing.</p></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="c-with-classes">C with Classes</h1><p><strong>Bjarne Stroustrup</strong> at Bell Labs develops his own language.</p><blockquote><ul><li>Motivated by higher-level programming languages like Simula<ul><li>Simula supports object-oriented programming.</li></ul></li><li>Based on C because of the power of C</li><li>C with classes ultimately turns into C++</li><li>C++ was a superset of C but had higher level objects<ul><li>This allowed users to create their own types.</li></ul></li></ul></blockquote><div class="notes"><p>"Bjarne Stroustrup, a Dane with a Ph.D. from Cambridge University (England), had used the Simula
language for distributed systems simulations in his research. He was disappointed with its poor
performance, however, and in 1979 when his new employer, AT&amp;T Bell Labs, said "Do something interesting",
he decided to infuse the C language with some Simula features he had grown accustomed to -- most notably classes --
and thus "C with Classes" was born. It caught on within AT&amp;T, was dubbed C++, and then proceeded to become a support
burden for its inventor.  -- taken from <a href="http://www.stroustrup.com/cuj_interview.html">http://www.stroustrup.com/cuj_interview.html</a></p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="factoids">Factoids</h1><blockquote><ul><li>First C with classes compiler was called "Cfront" which was derived from a C compiler called CPre</li><li>Cfront was written mostly in C with Classes, making it a compiler that could compile itself.</li><li>The name C with classes was changed in 1983 to C++ and new features were added<ul><li>virtual functions</li><li>function overloading</li><li>references</li><li>const</li><li>single-line comments</li></ul></li></ul></blockquote></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="road-to-standardization">Road to Standardization</h1><ul><li>1985 "The C++ Programming Language" first edition is released</li><li>Popularity soars into the 90s largely credited to OOP and GUI programming</li><li>A decision to standardize the language is made and group has first meeting in 1989<ul><li>The language will be controlled by a group of people instead of one member.</li><li>Stroustrup remains an influential member to the ISO C++ committee to this day.</li><li>First goals were to standardize iostreams, add templates, and exceptions.</li></ul></li></ul><div class="notes"><ul><li>The 1985 was a very important reference as the language wasn't standardized yet.</li></ul></div></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="lack-of-standard-library">Lack of standard library</h1><ul><li>1993 Standard was almost complete.</li><li>Committee felt there wasn't a good enough standard library.</li><li>Alex Stepanov gave a presentation on generic programming which put templates to good use.</li><li>By the next meeting Stepanov had refined the "Standard Template Library".</li><li>The committee liked it even if it delayed the completion of the standard.</li><li>It wasn't until 1998 that the C++ standard was finalized.</li></ul><div class="notes"><p>This were winding down in 1993 but uneasiness about a lack of robustness in the standard library cause .</p></div></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="boost">Boost</h1><ul><li>Also in 1998 Beman Dawes with Library Working Group chair, set up the Boost Libraries.</li><li>Libraries that might be candidates for standardization could be vetted and popularize.</li><li>Boost is separate from the standards process.</li><li>Library writers don't have to submit their libraries to boost but is usually happens that way.</li></ul><img src="images/boost.jpg"></img></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="c-as-a-superset-of-c">C++ as a superset of C</h1><ul><li><strong>Pros</strong><ul><li>Instant access to all libs written in C</li><li>Introduce safer ways to deal with resources RAII</li><li>Higher-level concepts (Generic but most of this class will be teaching this.)</li></ul></li><li><strong>Cons</strong><ul><li>Inherits all of C's baggage</li><li>Making more powerful user-defined types of C++ integrate
with C so that they behave the same was also difficult.</li></ul></li></ul><div class="notes"><p>I thought this was the appropriate place for this because before C++11 this is largely how
C++ was thought of.</p><p>C baggage...
Memory management...
Non-safe functions...
Redundant non-generic code.
Unsafe returned values.
Uninitialized variables.
Unsafe arrays.</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="c-03">C++03</h1><p>Not much changed...</p><p>Really.</p><p>The differences are so few and so technical that they ought not concern users <a class="footnoteref" id="footnote-backref-id1" href="#footnote-id2">[1]</a>.</p><div class="footnote" id="footnote-id2"><a class="footnotereturn" href="#footnote-backref-id1" title="return to content">#1: </a><p><a href="ftp://ftp.research.att.com/pub/c++std/WP/CD2">ftp://ftp.research.att.com/pub/c++std/WP/CD2</a></p></div></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="c-0x">C++0x</h1><p>"C++0x is a relict of the days where I and other, hoped for a C++08 or C++09. Think of 'x' as
hexadecimal (i.e., C++0B == C++11)" - Stroustrup</p><blockquote><ul><li>C++11 incorporates a lot of new features and getting all of that in took time.</li><li>Concepts were voted out in 2009 because of their complexity and the fact that they would have further delayed the release of the standard <a class="footnoteref" id="footnote-backref-id3" href="#footnote-id4">[2]</a>.</li></ul></blockquote><div class="footnote" id="footnote-id4"><a class="footnotereturn" href="#footnote-backref-id3" title="return to content">#2: </a><p><a href="http://www.drdobbs.com/cpp/the-c0x-remove-concepts-decision/218600111">http://www.drdobbs.com/cpp/the-c0x-remove-concepts-decision/218600111</a></p></div><div class="notes"><p>C++0x was the original name of the next version of the standard. It was labeled C++0x because it was supposed to be done sometime in the 2000s.</p></div></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="c-11-language-features">C++11 Language Features</h1><p><strong>"Surprisinglly, C++11 feels like a new language" - Stroustrup</strong></p><p>Some of the <a href="http://www.stroustrup.com/C++11FAQ.html#language">features</a>:</p><ul><li><a href="http://www.stroustrup.com/C++11FAQ.html#init-list">initializer-list</a></li><li><a href="http://www.stroustrup.com/C++11FAQ.html#uniform-init">uniform initialization</a></li><li><a href="http://www.stroustrup.com/C++11FAQ.html#template-alias">template aliases</a></li><li><a href="http://www.stroustrup.com/C++11FAQ.html#rval">rvalue references</a> and move semantics</li><li><a href="http://www.stroustrup.com/C++11FAQ.html#default">defaulted and deleted functions</a></li><li><a href="http://www.stroustrup.com/C++11FAQ.html#variadic-templates">variadic templates</a></li><li><a href="http://www.stroustrup.com/C++11FAQ.html#auto">auto</a></li><li><a href="http://www.stroustrup.com/C++11FAQ.html#inheriting">inherited constructors</a></li><li><a href="http://www.stroustrup.com/C++11FAQ.html#decltype">decltype</a></li></ul><div class="notes"><p>IMHO the best feature and the one that added the most performance was rvalue references and move semantics.</p></div></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="c-14-language-features">C++14 Language Features</h1><ul><li>Return type deduction for functions</li><li>Generic lambdas</li><li>Extended capturing in lambdas</li><li>Revised restrictions on constexpr functions</li><li>constexpr variable templates</li></ul><p><a href="http://cpprocks.com/an-overview-of-c14-language-features/">http://cpprocks.com/an-overview-of-c14-language-features/</a></p><div class="notes"><p>not as much stuff as C++11 but didn't take as long to get out. Notice concepts still aren't in the language and were voted out of C++17 as well.</p></div></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="state-of-the-compiler">State of the compiler</h1><p>There are three dominant compilers</p><ul><li>MSVC - Microsoft Visual C++</li><li>G++ - Gnu C++ compiler</li><li>clang - An opensource frontend, part of the LLVM compiler Infrastructure.</li></ul><div class="notes"><p>Add links...</p><p>Add information about each and how they related (maybe a link to a comparison with a break down of supported features)</p><p>I didn't want to put the features supported of each in this slide as that will change over time.</p></div></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="resources">Resources</h1><ul><li><a href="http://en.cppreference.com">cppreference.com</a></li><li><a href="https://github.com/isocpp/CppCoreGuidelines">C++ Core Guidelines</a> and the <a href="https://www.youtube.com/watch?v=1OEu9C51K2A">talk on them</a></li></ul><h1 id="a-look-at-the-c-type-system">A look at the C++ type system</h1><img src="images/invisablesoftware.jpg"></img><div class="notes"><p>A good type system should stay out of the way of a programmer. It should allow a programmer to build their own types that are representative of the problem that they are trying to solve. It should allow these types to be used in the same way as built in types. C++ provides a rich set of types through the normal primitives as well as its standard library. C++ also provides ways to extend these types and to create user defined types which can be used in much the same way. This presentation is a look at the different types provided by C++.</p></div></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="std-is-fundamental">std::is_fundamental</h1><ul><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span></tt>: all types that can be used for math.<ul><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point</span></tt>: <tt>float, double, long double</tt></li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span></tt><ul><li><tt>bool</tt></li><li><strong>character types</strong>: <tt>char, signed char, unsigned char, char16_t, char32_t, wchar_t</tt></li><li><strong>signed integers</strong>: <tt>short int, int, long int, long long int</tt></li><li><strong>unsigned integers</strong>: <tt>unsigned short, unsigned int, unsigned long, unsigned long long</tt></li></ul></li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_void</span></tt>:</li><li><tt><span class="n">std</span><span class="o">::</span><span class="nl">is_null_pointer</span><span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span></tt></li></ul></li></ul><div class="notes"><p>We are using <tt>&lt;type_traits&gt;</tt> to talk about the C++ type system.</p><p><a href="http://en.cppreference.com/w/cpp/header/type_traits">http://en.cppreference.com/w/cpp/header/type_traits</a></p><p>Each of the <tt>std::is_*</tt> represents a type trait in the standard library that can be used to evaluate a type.
You will get more exposure to these in follow on assignments.</p></div></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="std-is-compound">std::is_compound</h1><ul><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_reference</span></tt>: reference types<ul><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span></tt>: lvalues to objects or functions</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_rvalue_reference</span></tt>: rvalues to objects or functions</li></ul></li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_pointer</span></tt>: pointer types to data or functions (not tied to objects)</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_member_pointer</span></tt>: pointer to data or function members of objects</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_array</span></tt>: array types</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_function</span></tt>: function types</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_enum</span></tt>: enumeration types</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_class</span></tt>: class types</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_union</span></tt>: a special class type</li></ul></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="machine-architectures-and-built-in-types">Machine Architectures and Built-in Types</h1><blockquote><p>There are four main data models in use today.</p></blockquote><ul><li><strong>32-bit systems</strong><ul><li>LP32 or 2/4/4 (int is 16-bit, long and pointer are 32-bit)<ul><li>Win16 API</li></ul></li><li>ILP32 or 4/4/4 (int, long, and pointer are 32-bit)<ul><li>Win32 API</li><li>Unix and Unix-like systems (Linux, Mac OS X)</li></ul></li></ul></li></ul><div class="notes"><p>The data model is an implementation choice of computer/software engineers about the sizes of fundamental types.</p><p>Other models do exists but are very rare. For example ILP64 (8/8/8: int, long, and pointer are 64-bit) do exists but
only appeared in some early model 64-bit Unix systems (e.g. Unicos on Cray).</p><p>The Win16 API is a legacy system that was used in Windows 1.0 to Windows 3.11, and for backwards compatibility is support to Windows 95/Windows ME.</p></div></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="id5">Machine Architectures and Built-in Types</h1><blockquote><p>There are four main data models in use today.</p></blockquote><ul><li><strong>64-bit systems</strong><ul><li>LLP64 or 4/4/8 (int and long are 32-bit, pointer is 64-bit)<ul><li>Win64 API</li></ul></li><li>LP64 or 4/8/8 (int is 32-bit, long and pointer are 64-bit)<ul><li>Unix and Unix-Like systems (Linux, Mac OS X)</li></ul></li></ul></li></ul><div class="notes"><p>This class will mostly be using ILP32 and LLP64 as we are on windows. I will work to show LP64 as well.</p></div></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="what-data-model-does-c-use">What data model does C++ use?</h1><ul><li>C++ compiles and runs on all of these systems.</li><li>Can the standard give us any guarantees that would be valid on all systems?</li><li>Is there any way to get portable types?</li></ul></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="c-guarantees-bounded-types">C++ guarantees bounded types</h1><h2 id="signedness">Signedness</h2><ul><li><strong>signed</strong> - target type will have signed representation (this is the default).</li><li><strong>unsigned</strong> - target type will have unsigned representation.</li></ul><h2 id="size">Size</h2><p><tt><span class="kt">short</span> <span class="kt">int</span> <span class="o">&lt;=</span> <span class="kt">int</span> <span class="o">&lt;=</span> <span class="kt">long</span> <span class="kt">int</span> <span class="o">&lt;=</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span></tt></p><ul><li><strong>short</strong> - at least 16 bits.</li><li><strong>long</strong> - at least 32 bits.</li><li><strong>long long</strong> - at least 64 bits. (since C++11)</li></ul></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="a-portable-type-model">A portable type model</h1><p>What if your in a situation where you need to grantee that you type is a certain size on
all architectures.</p><pre class="highlight code C++"><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt; //since C++11</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt; //before C++11</span><span class="cp">
</span>
<span class="kt">uint32_t</span> <span class="n">is_a_32_bit_unsigned_int</span><span class="p">;</span>
<span class="kt">uint8_t</span>  <span class="n">is_a_8_bit_unsigned_char</span><span class="p">;</span>
<span class="kt">int64_t</span>  <span class="n">is_a_64_bit_signed_int</span><span class="p">;</span>
<span class="kt">uint_fast16_t</span> <span class="n">is_whatever_the_fastest_16bit_type_for_the_machine_is</span><span class="p">;</span></pre></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="c-floating-point-types">C++ Floating Point Types</h1><ul><li><strong>float</strong> - single precision. Usually IEEE-754 32 bit floating point type.</li><li><strong>double</strong> - double precision. Usually IEEE-754 64 bit floating point type.</li><li><strong>long double</strong> - extended precision.<ul><li>Doesn't have to map to types mandated by IEEE-754.</li><li>Usually 80-bit x87 floating point type on x86 and x86-64 architectures.</li></ul></li></ul><div class="notes"><p>x87 is a floating-point subset of the x86 architecture instruction set. Originated as an extension of the 8086 instruction set. This was back with coprocessors would work in tandem with x86 CPUs. The orginal x87 processor was 5 MHz. Todays processors are able to do these computation over 50,000 times faster.</p></div></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="user-defined-types">User defined types</h1><p>C++ allows programmers to create their own types. The standard library is a collection of user defined types.</p><ul><li>Classes</li><li>Structs (Really a type of class)</li><li>Enums</li><li>Unions</li></ul><div class="notes"><p>We will cover classes and structs in their own lecture.</p></div></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="c-style-un-scoped-enums">C Style Un-scoped Enums</h1><pre class="highlight code C++"><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">yellow</span><span class="p">};</span>
<span class="n">Color</span> <span class="n">light</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span>
<span class="k">switch</span><span class="p">(</span><span class="n">light</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="nl">red</span> <span class="p">:</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"red light</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">green</span> <span class="p">:</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"green light</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">yellow</span><span class="p">:</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">"yellow light</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><h1 id="unscoped-enums-with-initializers">Unscoped Enums with initializers</h1><pre class="highlight code C++"><span class="k">enum</span> <span class="n">Foo</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">+</span><span class="n">c</span> <span class="p">};</span>
<span class="c1">//a=0, b=1, c=10, d=11, e=1, f=2, g=12</span></pre></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="problems-with-enums">Problems with enums</h1><ul><li>Polluted the global scope<ul><li>No two <tt>enums</tt> could have the same names for their members.</li><li>Collisions could happen when pulling in other peoples code.</li></ul></li></ul></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="c-11-and-later-enums">C++11 and later Enums</h1><pre class="highlight code C++"><span class="k">enum</span> <span class="nl">name</span><span class="p">:</span> <span class="n">type</span> <span class="p">{</span><span class="n">enumerator</span> <span class="o">=</span> <span class="k">constexpr</span><span class="p">,</span> <span class="n">enumerator</span> <span class="o">=</span> <span class="k">constexpr</span><span class="p">,</span> <span class="p">...</span> <span class="p">};</span>

<span class="c1">// or better yet.
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">name</span><span class="o">:</span> <span class="n">type</span> <span class="p">{</span><span class="n">enumerator</span> <span class="o">=</span> <span class="k">constexpr</span><span class="p">,</span> <span class="n">enumerator</span> <span class="o">=</span> <span class="k">constexpr</span><span class="p">,</span> <span class="p">...};</span></pre></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="c-11-enum-example">C++11 Enum Example</h1><pre class="highlight code C++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Light</span> <span class="o">:</span> <span class="kt">char</span> <span class="p">{</span><span class="n">red</span><span class="o">=</span><span class="sc">'R'</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="sc">'G'</span><span class="p">,</span> <span class="n">yellow</span><span class="o">=</span><span class="sc">'Y'</span><span class="p">};</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">{</span><span class="n">red</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">yellow</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">brown</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Color</span> <span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
    <span class="n">Light</span> <span class="n">light</span> <span class="o">=</span> <span class="n">Light</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="unions">Unions</h1><pre class="highlight code C++"><span class="k">typedef</span> <span class="k">union</span> <span class="n">ARGB</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">color</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">componentsTag</span>
    <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">a</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">b</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">g</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span><span class="n">components</span><span class="p">;</span>
<span class="p">}</span><span class="n">pixel</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pixel</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="mh">0x334455AA</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"R: 0x"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"G: 0x"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B: 0x"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A: 0x"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre><div class="notes"><p>Unions can also be useful to building a variant type of basic types. Unions can't hold complex types in pre C++11.
C++11 allows for one data member that can have a default constructor.</p></div></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><h1 id="literals">Literals</h1><p>There are many more literals in C++ than C. In C++ you can even create your own literals.
C++ provides literals for:</p><ul><li>Integers</li><li>Floating Point</li><li>Character</li><li>String</li><li>nullptr (C++11)</li><li>user defined (C++11)</li></ul></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="integer-literals">Integer Literals</h1><ul><li><strong>decimal-literal</strong>: <tt>123432</tt> (a literal number)</li><li><strong>octal-literal</strong>: <tt>034532</tt></li><li><strong>hex-literal</strong>: <tt>0xDEADBEEF</tt></li><li><strong>binary-literal</strong>: <tt>0b1110010101101</tt> (C++14)</li><li><strong>integer suffix</strong><ul><li><strong>unsigned suffix</strong>: <tt>u</tt> or <tt>U</tt> (i.e. <tt>0xDEADBEEFU</tt> or <tt>123432u</tt>)</li><li><strong>long-suffix</strong>: <tt>l</tt> or <tt>L</tt> (i.e. <tt>0xDEADBEEFL</tt> will be <tt>0x00000000DEADBEEF</tt> on LP64)</li><li><strong>long-long-suffix</strong>: <tt>ll</tt> or <tt>LL</tt> (C++11)</li></ul></li><li>optionally single quotes (') may be inserted between the digits. These are ignored by the compiler. (C++14)</li></ul></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><h1 id="floating-point-literals">Floating Point Literals</h1><ul><li><strong>digit-sequence</strong>: whole number without a decimal seperator, exponent not optional <tt>1e10</tt>, <tt>1e-5L</tt></li><li><strong>digit-sequence</strong>: <tt>1.e-1</tt> (in this case the exponent is optional)</li><li><strong>digit-sequence</strong>: <tt>3.14</tt>, <tt>1.42e100</tt></li><li><strong>hex-digit-sequence</strong>: <tt>0x1ffp10</tt> or <tt>0x1ff.p10</tt> or <tt>0x0.12fp-1</tt> exponent is never optional for hex-digit-sequences</li><li><strong>suffix</strong><ul><li>(no suffix) - defines <tt>double</tt></li><li><tt>f</tt> or <tt>F</tt> - defines <tt>float</tt></li><li><tt>l</tt> or <tt>L</tt> - defines <tt>long double</tt></li></ul></li></ul></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><h1 id="character-literals">Character Literals</h1><ul><li><tt>'c-char'</tt> - <tt>char</tt></li><li><tt>u8'c-char'</tt> - UTF-8 <tt>char</tt></li><li><tt>u'c-char'</tt> - UCS-2 character - <tt>char16_t</tt></li><li><tt>U'c-char'</tt> - UCS-4 character - <tt>char32_t</tt></li><li><tt>L'c-char'</tt> - wide character - implementation-defined</li><li><tt>'c-char-sequence'</tt> : Can be combined with the above prefixes.</li></ul></div><div class="step step-level-1" step="45" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><h1 id="character-literal-escape-sequences">Character Literal Escape Sequences</h1><ul><li><tt>\'</tt>: single quote</li><li><tt>\"</tt>: double quote</li><li><tt>\?</tt>: question mark</li><li><tt>\\</tt>: backslash</li><li><tt>\a</tt>: audible bell</li><li><tt>\b</tt>: backspace</li><li><tt>\f</tt>: form feed</li><li><tt>\n</tt>: new line</li><li><tt>\r</tt>: carriage return</li><li><tt>\t</tt>: horizontal tab</li><li><tt>\v</tt>: vertical tab</li><li><tt>\nnn</tt>: arbitrary octal value</li><li><tt>\Xnn</tt>: arbitrary hex value</li><li><tt>\Unnnn</tt>: Universal character name</li><li><tt>\Unnnnnnnn</tt>: universal character name</li></ul><div class="notes"><p>Of the octal escape sequences, 0 is the most useful as it represents the terminating null character in a null-terminated string.</p></div></div><div class="step step-level-1" step="46" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="64000" data-y="0" data-z="0"><h1 id="string-literals">String Literals</h1><p>Mostly the same as character literals</p><ul><li><tt>"unescaped or escaped characters"</tt></li><li><tt>L"unescaped or escaped characters"</tt></li><li><tt>u8"unescaped or escaped characters"</tt> (C++11)</li><li><tt>u"unescaped or escaped characters"</tt> (C++11)</li><li><tt>U"unescaped or escaped characters"</tt> (C++11)</li><li><tt>R"delimiter(raw characters)delimiter"</tt> (C++11)</li></ul><pre class="highlight code C++"><span class="c1">//Raw String Examples
</span><span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="n">R</span><span class="s">"foo("</span><span class="k">this</span> <span class="n">is</span> <span class="n">a</span> <span class="n">raw</span> <span class="n">string</span><span class="s">"/"</span><span class="n">I</span> <span class="p">(</span><span class="n">can</span><span class="p">)</span> <span class="n">use</span> <span class="n">all</span> <span class="n">kinds</span> <span class="n">of</span> <span class="err">'</span><span class="n">characters</span><span class="err">'</span><span class="s">")foo"</span><span class="p">;</span></pre></div><div class="step step-level-1" step="47" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65600" data-y="0" data-z="0"><h1 id="nullptr">nullptr</h1><p>A literal that represent <tt>NULL</tt>.</p><p>Why would we want that we already have <tt>NULL</tt> and 0?</p><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//do something with a
</span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//do something with a
</span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//calls foo(int)
</span>    <span class="n">foo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="c1">//calls foo(int)
</span>    <span class="n">foo</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">//calls foo(char*)
</span><span class="p">}</span></pre><div class="notes"><p>TODO: Add more reason for nullptr here.</p></div></div><div class="step step-level-1" step="48" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67200" data-y="0" data-z="0"><h1 id="pointers-references-and-const-oh-my">Pointers, References, and <tt>const</tt> oh my!</h1><ul><li><strong>Pointers</strong>: Are used to hold memory addresses can be dereferences to access the thing at an address.</li><li><strong>References</strong>: Are syntactic sugar, so that code is easier to read and write.</li></ul><ol><li>A pointer can be re-assigned any number of times while a reference can not be re-seated after binding.</li><li>Pointers can point to nowhere, references always refer to an object. (must be initialized)</li><li>You can't take the address of a reference like you can a pointer.</li><li>There is no reference arithmetic.</li></ol></div><div class="step step-level-1" step="49" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="68800" data-y="0" data-z="0"><h1 id="id6">Pointers, References, and <tt>const</tt> oh my!</h1><p><tt>const</tt> declares variables that can't be modified. Pay careful attention to applying const to pointers.</p><ul><li><tt>const int*</tt> is a pointer that can be re-assigned but points to constant data.</li><li><tt>int* const</tt> is a pointer that can't be re-assigned as it is const.</li><li><tt>const int* const</tt> is a pointer that is const and points to constant data.</li></ul><pre class="highlight code C++"><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0xCAFEF00D</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">//ERROR storing pointer to constant data in non-const pointer.
</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="n">ptr2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="n">ptr3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span> <span class="c1">//ERROR pointer is const and can't be modified.</span></pre></div><div class="step step-level-1" step="50" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="70400" data-y="0" data-z="0"><h1 id="id7">Pointers, References, and <tt>const</tt> oh my!</h1><h2 id="example">Example</h2><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//This prints the value of fooptr below.
</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo is at"</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">foo</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mh">0xCAFEF00D</span>
  <span class="kt">int</span><span class="o">&amp;</span> <span class="n">fooref</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">fooptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>
  <span class="n">fooref</span> <span class="o">+=</span> <span class="mh">0xEE0</span><span class="p">;</span> <span class="c1">//foo is now 0xCAFEFEED
</span>  <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="51" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="72000" data-y="0" data-z="0"><h1 id="constexpr-c-11">constexpr (C++11)</h1><p><em>Concept</em>: Value is not only constant but is also known at compile time!
<em>Reality</em>: You can't assume the results of a constexpr function are const, nor that they are known at compile time.</p><dl><dt><tt>constexpr</tt> can be applied to variables and functions.</dt><dd><ul><li>object</li><li>function</li><li>function templates</li></ul></dd></dl><pre class="highlight code C++"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">beef</span> <span class="o">=</span> <span class="mh">0xCAFEBEEF</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">beefref</span> <span class="o">=</span> <span class="n">beef</span><span class="p">;</span> <span class="c1">//bound to reference beef (can't be changed)
</span><span class="k">constexpr</span> <span class="kt">int</span><span class="o">*</span> <span class="n">beefptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">beefref</span><span class="p">;</span> <span class="c1">//because beefref is a reference it can be used like beef
</span><span class="k">static_assert</span><span class="p">(</span><span class="n">beef</span> <span class="o">==</span> <span class="n">beefref</span> <span class="o">&amp;&amp;</span> <span class="n">beef</span> <span class="o">==</span> <span class="o">*</span><span class="n">beefptr</span><span class="p">,</span> <span class="s">"These should all be equal here"</span><span class="p">);</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">square</span><span class="p">(</span><span class="mi">2</span><span class="p">)];</span> <span class="c1">//allowed because of constexpr</span></pre><p><tt>static_assert</tt> is a <strong>compile</strong> time assert that will output the message argument as an error if the assertion fails. <tt>static_assert</tt> must be given a boolean condition that is <tt>constexpr</tt>.</p></div><div class="step step-level-1" step="52" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="73600" data-y="0" data-z="0"><h1 id="constexpr-objects-c-11">constexpr objects (C++11)</h1><ul><li>objects are in fact const</li><li>Values are known at translation<ul><li>Translation consists not just of compilation but also of linking.</li></ul></li><li>Because known at compilation time:<ul><li>Values can be placed in Read-only memory</li><li>Integral values that are const and known at compile time can be used where C++ requires integral constant expressions
* std::array, Template arguments, array sizes, etc...</li><li>Note that const does not offer the same guarantee as constexpr, because objects need not be initialized with values known at compile time.</li></ul></li></ul></div><div class="step step-level-1" step="53" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="75200" data-y="0" data-z="0"><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
 <span class="kt">double</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">constexpr</span> <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">x_</span><span class="p">{</span><span class="n">x</span><span class="p">},</span> <span class="n">y_</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="p">{}</span>
  <span class="k">constexpr</span> <span class="n">doube</span> <span class="n">xValue</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">x_</span><span class="p">;}</span>
  <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">yValue</span><span class="p">()</span> <span class="k">const</span> <span class="n">no</span> <span class="n">except</span> <span class="p">{</span><span class="k">return</span> <span class="n">y_</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setX</span><span class="p">(</span><span class="kt">double</span> <span class="n">newX</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span><span class="n">x_</span><span class="o">=</span><span class="n">newX</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setY</span><span class="p">(</span><span class="kt">double</span> <span class="n">newY</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span><span class="n">y_</span><span class="o">=</span><span class="n">newY</span><span class="p">;}</span>
 <span class="p">};</span>

<span class="k">constexpr</span> <span class="n">Point</span> <span class="nf">p1</span><span class="p">(</span><span class="mf">9.4</span><span class="p">,</span> <span class="mf">27.7</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="n">Point</span> <span class="nf">p2</span><span class="p">(</span><span class="mf">28.8</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">);</span>

<span class="k">constexpr</span> <span class="nf">midpoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span>  <span class="p">{</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">xValue</span><span class="p">()</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="n">xValue</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">yValue</span><span class="p">()</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="n">yValue</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">Point</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span> <span class="c1">//THIS EXIST IN READ ONLY MEMORY!!!</span></pre></div><div class="step step-level-1" step="54" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="76800" data-y="0" data-z="0"><h1 id="constexpr-functions-c-11">constexpr functions (C++11)</h1><ul><li>shall have exactly one return statement.</li><li>return type shall be a literal type. (not void)</li><li>parameters shall be literal types.</li><li>function body shall be a compound-statement of the form {return expression;}<ul><li>C++14 lifts this restriction</li><li>In C++11 you can get a little more bang utilizing "? :"  and recursion.</li></ul></li><li>Returns a constexpr result if the values of the arguments passed to constexpr are known at compile time.</li><li>If called with values that are not known acts as a normal function.</li></ul></div><div class="step step-level-1" step="55" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="78400" data-y="0" data-z="0"><pre class="highlight code C++"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>              <span class="c1">//OK
</span>
<span class="k">constexpr</span> <span class="kt">long</span> <span class="nf">long_max</span><span class="p">()</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">2147483647</span><span class="p">;</span> <span class="p">}</span>       <span class="c1">//OK
</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">abs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">//OK
</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="c1">//... do stuff     }       //ERROR: return type is void
</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">prev</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="o">--</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>              <span class="c1">//ERROR: Use of decrement works with clang
</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="c1">//ERROR: C++11 doesn't allow this but C++14 does!
</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">n</span> <span class="p">)</span> <span class="n">r</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="56" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="80000" data-y="0" data-z="0"><h1 id="runtime-sized-arrays-c-14">Runtime-Sized Arrays C++14</h1><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//This is ok in C++14
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="57" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="81600" data-y="0" data-z="0"><h1 id="id8">decltype</h1><p><tt>decltype(e)</tt> deduce and returns the type of its argument e.</p><ul><li>If the expression e refers to a variable in local or namespace scope, a static member variable or a function parameter, the the result is that variable's or parameter's declared type.</li><li>If <tt>e</tt> is a function call or an overloaded operator invocation, <tt>decltype(e)</tt> denotes the declared return type of that function.</li><li>Otherwise, if e is an lvalue, <tt>decltype(e)</tt> is <tt>T&amp;</tt>, where <tt>T</tt> is the type of <tt>e</tt>; if e is an rvalue; the result is <tt>T</tt>.</li></ul><pre class="highlight code C++"><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//c has type int
</span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//d has type int
</span><span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span> <span class="c1">//e has type int, the type of the entity named by c
</span><span class="k">decltype</span><span class="p">((</span><span class="n">c</span><span class="p">))</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//f has type int&amp;, because (c) is an lvalue
</span><span class="k">decltype</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">g</span><span class="p">;</span> <span class="c1">//g has type int, because 0 is an rvalue</span></pre><div class="notes"><p>These semantics were designed to fulfill the needs of generic library writers, while at the same time being intuitive for novice programmers, because the return type of decltype always matches the type of the object or function exactly as declared in the source code. More formally, Rule 1 applies to unparenthesized id-expressions and class member access expressions. For function calls, the deduced type is the return type of the statically chosen function, as determined by the rules for overload resolution.</p></div></div><div class="step step-level-1" step="58" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="83200" data-y="0" data-z="0"><h1 id="auto-c-11">auto (C++11)</h1><p><tt>auto</tt> is a generic type that use type deduction to figure out the type at compile time. Auto has the following features.</p><ul><li>Must be initialized.</li><li>Adapts well to refactoring.</li><li>Efficient by default (no implicit conversions)</li><li>Generally simpler and less typing.</li><li>Defaults to by value.</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span> <span class="c1">// standard function pointer.
</span>    <span class="k">auto</span> <span class="n">auto_fp</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// function to pointer conversion
</span>    <span class="k">const</span> <span class="k">auto</span> <span class="n">auto_fp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span> <span class="c1">// equivalent to auto_fp
</span>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">auto_fr</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// reference
</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bar</span><span class="p">;</span>
    <span class="n">auto_fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bar</span><span class="p">;</span>
    <span class="n">auto_fp2</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">//ERROR would work if not const.
</span>    <span class="n">auto_fr</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">//COMPILATION ERROR
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="59" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="84800" data-y="0" data-z="0"><h1 id="type-casting">Type Casting</h1><p>C-style casts actually represent different types of cast in one operator</p><ul><li>static-cast - usually safe</li><li>const-cast - <strong>dangerous</strong></li><li>reinterpret-cast - <strong>dangerous</strong></li></ul><p>C++ separates these all out for safety reasons. C++ also adds one more type of cast.</p><ul><li>dynamic-cast</li></ul></div><div class="step step-level-1" step="60" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="86400" data-y="0" data-z="0"><h1 id="widening-conversions-promotion">Widening Conversions (promotion)</h1><p>These are safe to do because there is no potential for a loss of data. Because these are safe, the compiler will
preform them silently and not issue any warnings.</p><img src="images/widening_conversion.png"></img></div><div class="step step-level-1" step="61" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="88000" data-y="0" data-z="0"><h1 id="narrowing-conversions-coercion">Narrowing Conversions (coercion)</h1><p>These are the opposite of a widening conversion. Because they are a cast from a larger type to a smaller one there
is a possibility for data loss, making the conversion potentially unsafe. If your sure that the conversion is ok and there will be no loss of data, use an explicit cast to get rid of the compiler warning.</p><pre class="highlight code C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">INT_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//integer overflow
</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mf">1.9f</span><span class="p">;</span> <span class="c1">//possible loss of data</span></pre><div class="notes"><p>I had to increase the warning level to 4 in visual studio to get these warning to show up.</p></div></div><div class="step step-level-1" step="62" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="89600" data-y="0" data-z="0"><h1 id="static-cast-new-type-expression">static_cast&lt;new_type&gt;(expression);</h1><p>This is allowed when there is a valid conversion in the language, or an appropriate constructor that makes it possible. The danger with static cast is casting down between inherited classes and narrowing conversions.</p><ul><li>static_cast are checked at <strong>compile</strong> time only</li><li>static_cast return an error when trying to cast between things that are incompatible</li><li>static_cast can be used to cast between pointer to base and pointer to derived<ul><li>static_cast can't tell if it is safe at runtime.</li><li>dynamic_cast should be used to these situations to do runtime checks to see if the conversion is safe.</li></ul></li></ul><pre class="highlight code C++"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">big</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
<span class="kt">short</span> <span class="n">a</span> <span class="o">=</span> <span class="n">big</span><span class="p">;</span> <span class="c1">//conversion from 'int' to 'short', possible loss of data
</span><span class="kt">short</span> <span class="n">b</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">big</span><span class="p">);</span> <span class="c1">//no error</span></pre></div><div class="step step-level-1" step="63" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="91200" data-y="0" data-z="0"><h1 id="const-cast-new-type-expression">const_cast&lt;new_type&gt;(expression);</h1><p>Usually a sign of a bad design and shouldn't be used in new projects. The purpose of const is to keep a developer from modifying the argument. const_cast removes this restriction and breaks promises to a user that you wouldn't modify the data.</p><ul><li>can remove const or volatile modifiers</li><li>only really helpful with legacy APIs that are not const correct.
* APIs without a const interface that don't modify anything.</li></ul><pre class="highlight code C++"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//a and b == 0xDEADBEF0;</span></pre></div><div class="step step-level-1" step="64" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="92800" data-y="0" data-z="0"><h1 id="reinterpret-cast-new-type-expression">reinterpret_cast&lt;new_type&gt;(expression);</h1><p>This is also usually a sign of bad code.</p><p>Converts between types by reinterpreting the underlying bit pattern.</p><ul><li>Does not compile to any CPU instructions<ul><li>Simply instructs compiler to teat a series of bytes as something else.</li></ul></li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">reinterpret_Cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\x7'</span><span class="p">)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This system is little-endian</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="k">else</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This system is big-endian</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span></pre></div><div class="step step-level-1" step="65" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="94400" data-y="0" data-z="0"><h1 id="smart-pointers">Smart Pointers!</h1><p>Smart pointers are a better way to utilize memory in C++. They overcome many of the problems with normal pointers and better express the meaning of a particular pointer. It is still valid to pass pointers in C++ but this conveys nothing about ownership. The smart pointers that we will be discussing were added to the standard in C++11.</p><ul><li>std::share_ptr&lt;type_pointed_too&gt;(pointer);</li><li>std::weak_ptr&lt;type_pointed_too&gt;(pointer);</li><li>std::unique_ptr&lt;type_pointed_too&gt;(pointer);</li></ul><div class="notes"><p>All of these types are a part of the standard library.</p></div></div><div class="step step-level-1" step="66" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="96000" data-y="0" data-z="0"><h1 id="problems-found-with-normal-pointers">Problems found with normal pointers</h1><ul><li>Knowing who <strong>owns</strong> the pointer, i.e. who is responsible for freeing the memory.</li><li>Forgetting to free the memory.</li><li>Freeing the memory more than once.</li><li>Not initializing memory.</li></ul></div><div class="step step-level-1" step="67" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="97600" data-y="0" data-z="0"><h1 id="std-shared-ptr-type">std::shared_ptr&lt;type&gt;</h1><h2 id="multiple-people-own-me">Multiple people own me!</h2><ul><li>Shared pointer introduces a small cost to do reference counting.<blockquote><ul><li>It keeps track of the number of users</li><li>When all users are done with it, it frees the memory.</li></ul></blockquote></li><li>Can be created with make_shared&lt;type&gt;();</li></ul><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">bar</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a number: "</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
   <span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre><div class="notes"><p>One important thing to note is that there are no news or deletes in this code. There is nothing that needs to be reviewed to find all cases that we may need to free our dynamic memory. It is all handled by the shared_ptr.</p></div></div><div class="step step-level-1" step="68" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="99200" data-y="0" data-z="0"><h1 id="std-unique-ptr-type">std::unique_ptr&lt;type&gt;</h1><h2 id="only-one-can-own-me">Only one can own me!</h2><ul><li>Only one indirection compared to a raw pointer. (almost no overhead)</li><li>Can not be copied or assigned.</li><li>Can only be moved (meaning it is fast and there is only one copy).</li><li>std::move leaves the state of the object moved as undefined.<ul><li>testing with unique_ptr shows that the default deleter will set the moved from unique_ptr to nullptr.</li></ul></li></ul><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">bar</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a number: "</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
   <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>

   <span class="c1">//bar is nullptr
</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="69" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="100800" data-y="0" data-z="0"><h1 id="std-weak-ptr-type">std::weak_ptr&lt;type&gt;</h1><h2 id="nobody-owns-me-yet">Nobody owns me... yet</h2><ul><li>weak_ptr can be used to hold a weak reference to a shared_ptr.<ul><li>They don't increase the ref count of the shared_ptr</li><li>The shared_ptr may be free'd even while a weak_ptr exists.</li><li>weak_ptr must be promoted to a share_ptr in order to actually use the data.</li></ul></li></ul><pre class="highlight code C++"><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gw</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">spt</span> <span class="o">=</span> <span class="n">gw</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Has to be copied into a shared_ptr before usage
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">spt</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"gw is expired</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
        <span class="n">gw</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
        <span class="n">f</span><span class="p">();</span> <span class="c1">// 42
</span>    <span class="p">}</span>
    <span class="n">f</span><span class="p">();</span> <span class="c1">// gw is expired
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="70" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="102400" data-y="0" data-z="0"><h1 id="an-overview-of-the-standard-template-library">An Overview of the Standard Template Library</h1><p>The heart of the C++ standard library is the STL.
* Generic library
* Allows users to take advantage of data structures and algorithms without knowing how they work.
* All components are templates</p><h2 id="parts-of-the-stl">Parts of the STL</h2><ul><li><strong>Containers</strong>: Used to manage collections, each container has its own advantages and disadvantages.</li><li><strong>Iterators</strong>: A generic way to step through the containers. Can be thought of as a type of pointer. To advance you <tt>++itr</tt> and to access you <tt>*itr</tt>.</li><li><strong>Algorithms</strong>: Used to process elements of a collection. Algorithms use iterators.</li></ul><dl><dt>In a way, the STL is a departure from object oriented programming:</dt><dd><p>The STL separates the data from the algorithms rather than combining them. In principle, you can combine every kind of container with every kind of algorithm.</p></dd></dl></div><div class="step step-level-1" step="71" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="104000" data-y="0" data-z="0"><h1 id="containers">Containers</h1><img src="images/Containers.png" width="700px"></img><ul><li><strong>Sequence Containers</strong>: are <em>ordered collections</em> in which every element has a certain position.</li><li><strong>Associative Containers</strong>: are <em>sorted collections</em> in which the position of an element depends on its value due to a certain sorting criterion. The order of insertion doesn't matter.</li><li><strong>Unordered Containers</strong>: are <em>unordered collections</em> where the only important question is if a specific element is in such a collection.</li></ul></div><div class="step step-level-1" step="72" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="105600" data-y="0" data-z="0"><h1 id="choosing-a-container">Choosing a container</h1><p>When choosing a container we must think about how that container will be used.</p><p>If a container will need to be searched frequently it may be wise to use an associative container that stores the data in sorted order. In this way we can use a binary search.</p><h2 id="on-average">On Average:</h2><table cellpadding="0" cellspacing="0"><thead><tr><th><p><strong>Elements</strong></p></th><th><p><strong>BinSearch</strong></p></th><th><p><strong>Linear Search</strong></p></th></tr></thead><tbody><tr><td><p>1000</p></td><td><p>10</p></td><td><p>500</p></td></tr><tr><td><p>2000</p></td><td><p>11</p></td><td><p>1000</p></td></tr><tr><td><p>16000</p></td><td><p>14</p></td><td><p>8000</p></td></tr></tbody></table><p>This is why it is important that we understand how these algorithms and data structures work.</p></div><div class="step step-level-1" step="73" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="107200" data-y="0" data-z="0"><h1 id="big-o-notation">Big-O Notation</h1><table cellpadding="0" cellspacing="0"><thead><tr><th><p>Type</p></th><th><p>Notation</p></th><th><p>Meaning</p></th></tr></thead><tbody><tr><td><p>Constant</p></td><td><p>O(1)</p></td><td><p>The runtime is independent of the number of elements</p></td></tr><tr><td><p>Logarithmic</p></td><td><p>O(log(n))</p></td><td><p>Runtime grows logarithmically with the number of elements</p></td></tr><tr><td><p>Linear</p></td><td><p>O(n)</p></td><td><p>The runtime grows at a linear ratio to n</p></td></tr><tr><td><p>n-log-n</p></td><td><p>O(n*log(n))</p></td><td><p>The runtime grows as a product if linear and log complexity</p></td></tr><tr><td><p>Quadratic</p></td><td><p>O(n^2)</p></td><td><p>The runtime grows quadratically with n</p></td></tr></tbody></table><h2 id="examples">Examples</h2><img src="images/BigO.png" width="700px"></img></div><div class="step step-level-1" step="74" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="108800" data-y="0" data-z="0"><h1 id="vectors">Vectors</h1><p><tt>std::vector</tt> maintains an internal array and allows a user to dynamically grow that array at the end of the array.</p><ul><li>allocates an initial capacity that is up to the implementation.<ul><li>We can see the current capacity with .capacity()</li><li>We can set a capacity with .reserve()</li></ul></li><li>if the user grows the capacity greater than a vector can handle the vector class will grow the capacity. (Again how this is done is implementation specific)<ul><li>When the size grows beyond what the vector can hold all items must be copied.</li><li>The cost of this copy is amortized if the increase of capacity is exponential.<ul><li>This means that the cost to push an element back is O(1).</li></ul></li></ul></li><li>if a vector grows very large but then shrinks and likely won't grow that big again you could waste memory.<ul><li>A call to <tt>shrink_to_fit</tt> (C++11) will reduce the memory usage by freeing unused memory.</li></ul></li><li>Inserting elements at the end is fast</li><li>Inserting elements into the middle is slow</li><li>Data is stored contiguously (Good for caching and memcpy)</li></ul></div><div class="step step-level-1" step="75" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="110400" data-y="0" data-z="0"><h1 id="id9">Vectors</h1><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Create a vector containing integers
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>

    <span class="c1">// Add two more integers to vector
</span>    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>

    <span class="c1">// Iterate and print values of vector
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="76" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="112000" data-y="0" data-z="0"><h1 id="deque">Deque</h1><p>Pronounced "deck" and is an abbreviation for "double-ended queue".</p><ul><li>Does not guarantee elements to be contiguous.</li><li>Has quick insertion in the front and back. O(1) amortized</li><li>Slow insertion in the middle. O(n)</li><li>Random access is fast. O(1)</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0U</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>

  <span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="77" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="113600" data-y="0" data-z="0"><h1 id="array">Array</h1><ul><li>Useful as a better C-Style Array.</li><li>Fixed size, Can only change the values not the number of elements</li><li>Size must be known at compile time.</li><li>If initialized on the stack the data will be on the stack.</li><li>Basically a light-weight wrapper for C-Arrays</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">25</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Hello"</span><span class="p">,</span> <span class="s">"World"</span><span class="p">};</span>

    <span class="k">for</span><span class="p">(</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="78" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="115200" data-y="0" data-z="0"><h1 id="list">List</h1><h2 id="a-doubly-linked-list">A doubly linked list.</h2><ul><li>Random access is slow. O(n)</li><li>Insertion and Removal at any point is fast. O(1)</li><li>Data is not contiguous.</li><li>Direct access using [], or at is not possible (because it would be SLOW).</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">abc</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span> <span class="p">...,</span> <span class="sc">'x'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="sc">'z'</span><span class="p">};</span>

    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">abc</span><span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="79" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="116800" data-y="0" data-z="0"><h1 id="forward-list-c-11">forward_list (C++11)</h1><ul><li>Saves memory by only having a pointer to the next element and not the previous</li><li>Has similar performance characteristics as a doubly link list.</li><li><dl><dt>Access to the end is O(n)</dt><dd><ul><li>push_back and size not supported as they would be slow.</li></ul></dd></dl></li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">primes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">17</span><span class="p">};</span>

    <span class="c1">//resize with POOR performance
</span>    <span class="n">primes</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
    <span class="n">prints</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">99</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="nl">elem</span><span class="p">:</span> <span class="n">primes</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="80" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="118400" data-y="0" data-z="0"><h1 id="associative-containers">Associative Containers</h1><ul><li>Members of the container are stored sorted</li><li>Finding elements is really fast</li><li>Typically implemented as a type of binary tree</li></ul><h2 id="the-containers">The Containers</h2><ul><li><strong>set</strong> is a collection in which elements are sorted according to their own values.</li><li><strong>multiset</strong> is a collection like the <strong>set</strong> that allows elements to exist more than once.</li><li><strong>map</strong> is a collection of elements with key/value pairs that is sorted based on the key.</li><li><strong>multimap</strong> is a collection like the map that allows elements to be in the collection multiple times.</li></ul></div><div class="step step-level-1" step="81" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="120000" data-y="0" data-z="0"><h1 id="set">Set</h1><pre class="highlight code C++"><span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span><span class="n">val_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val_</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">val_</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">getX</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">val_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">setX</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">5</span> <span class="p">};</span> <span class="c1">//Compilation error if X doesn't define operator &lt;
</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">setX</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="82" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="121600" data-y="0" data-z="0"><h1 id="multiset">MultiSet</h1><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">setX</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span> <span class="p">};</span> <span class="c1">//11 is in there twice!
</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">setX</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="83" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="123200" data-y="0" data-z="0"><h1 id="map-and-multimap">Map and Multimap</h1><ul><li>A very useful type.</li><li>Maybe faster than unorder_map if doing a large amount of insertions and removals</li><li>Sorted traversal</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ages</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="s">"Joe"</span><span class="p">,</span> <span class="mi">80</span> <span class="p">},{</span> <span class="s">"Jim"</span><span class="p">,</span> <span class="mi">55</span> <span class="p">},{</span> <span class="s">"Barbra"</span><span class="p">,</span> <span class="mi">34</span> <span class="p">},{</span> <span class="s">"Sara"</span><span class="p">,</span> <span class="mi">38</span> <span class="p">}</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">21</span><span class="p">,</span> <span class="s">"Joe"</span><span class="p">},</span> <span class="p">{</span><span class="mi">21</span><span class="p">,</span> <span class="s">"Jim"</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span> <span class="s">"Barbra"</span><span class="p">},</span> <span class="p">{</span><span class="mi">44</span><span class="p">,</span> <span class="s">"Tim"</span><span class="p">}</span> <span class="p">};</span>

    <span class="n">ages</span><span class="p">[</span><span class="s">"Jamie"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">45</span><span class="p">;</span>
    <span class="n">ages</span><span class="p">[</span><span class="s">"John"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">ages</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">people</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="84" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="124800" data-y="0" data-z="0"><h1 id="unordered-containers-c-11">Unordered Containers (C++11)</h1><h2 id="unordered-containers-are-hash-tables">Unordered Containers are Hash Tables!!</h2><ul><li>Great for lookups O(1)!!!</li><li>Amortized constant complexity if using a good hash function</li><li>May use a lot of memory.</li></ul><p>Containers are very similar to associative containers minus the sorted guarantee:</p><ul><li><strong>unordered set</strong>: A collection of unordered elements. Elements may only occur once.</li><li><strong>unordered multiset</strong>: The same as an unordered set but allows duplicates.</li><li><strong>unordered map</strong>: A collection of key/value pairs where the key is only allowed to be in the collection once.</li><li><strong>unordered multimap</strong>: The same a unordered map but allows for duplicate keys.</li></ul></div><div class="step step-level-1" step="85" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="126400" data-y="0" data-z="0"><h1 id="iterators">Iterators</h1><p>In C++11 we have range based for loops but sometimes we don't want to iterate one by one through the collection (find for example.)</p><h2 id="iterators-have-the-following-operators">Iterators have the following operators:</h2><ul><li><strong>operator*()</strong> Returns the element at the current position.</li><li><strong>operator++()</strong> Lets the iterator step forward to the next element. Most iterators also allow stepping backward with --.</li><li><strong>operator==()</strong> and <strong>operator!=()</strong> return weather two iterators represent the same position.</li><li><strong>operator=()</strong> Assigns an iterator</li><li>Iterators share an interface but are different types as they need to be specific to the type that they operate over.</li><li>All container classes provide a begin() and end() function to get the first and last iterator</li></ul><img src="images/range-begin-end.svg"></img></div><div class="step step-level-1" step="86" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="128000" data-y="0" data-z="0"><h1 id="id10">Iterators</h1><h2 id="an-example">An Example</h2><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">abcs</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span> <span class="p">..</span> <span class="p">,</span> <span class="sc">'x'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="sc">'z'</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">citr</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">citr</span> <span class="o">=</span> <span class="n">abcs</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">citr</span> <span class="o">!=</span> <span class="n">abcs</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">citr</span><span class="p">)</span> <span class="c1">//Here the ++citr matters
</span>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">citr</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ABCS</span><span class="p">(</span><span class="n">abcs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
   <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">abcs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">abcs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ABCS</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="p">});</span>

   <span class="c1">//Got tired of writing loops to print.
</span>   <span class="n">print</span><span class="p">(</span><span class="n">ABCS</span><span class="p">);</span>  <span class="c1">//will print any iterable type. See implementation in VS 2015
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="87" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="129600" data-y="0" data-z="0"><h1 id="functions-lambdas-and-std-function">Functions, Lambdas, and std::function</h1><img src="images\\quote-the-only-way-to-learn-a-new-programming-language-is-by-writing-programs-in-it.jpg"></img><div class="notes"><p>TODO...</p></div></div><div class="step step-level-1" step="88" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="131200" data-y="0" data-z="0"><h1 id="functions-in-c">Functions in C++</h1><p>Functions in C++ are very similar to functions in C and other languages.</p><ul><li>Can be overloaded</li><li>Parameters can be defaulted</li><li>Can be inlined at the choice of the compiler.</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// declaration
</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">arg2</span><span class="p">)</span> <span class="c1">// definition
</span><span class="p">{</span>
    <span class="c1">//does stuff and returns an int.
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="89" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="132800" data-y="0" data-z="0"><h1 id="function-overloading">Function Overloading</h1><p>Functions can have the same name so long as the signature is different</p><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span> <span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">//error impossible to differentiate between a call to foo() and a call to foo();
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//error foo(double) already defined.
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">double</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//error impossible to differentiate between a call to foo(2.0);
</span><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//int's are by default signed and therefore this is the same function as above.</span></pre></div><div class="step step-level-1" step="90" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="134400" data-y="0" data-z="0"><h1 id="default-parameters">Default Parameters</h1><p>In the declaration you can specify a default.</p><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">foo</span><span class="p">();</span> <span class="c1">//prints 4
</span>   <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//prints 1
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="91" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="136000" data-y="0" data-z="0"><h1 id="default-parameters-with-overloading">Default Parameters with overloading</h1><p>The compiler must be able to tell the difference between two functions. Defaulting parameters can affect this.</p><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//prints 1
</span>   <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//???
</span>   <span class="n">foo</span><span class="p">();</span> <span class="c1">//prints 2
</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="92" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="137600" data-y="0" data-z="0"><h1 id="inline">inline</h1><ul><li>serves as a indicator to the optimizer.</li><li>non binding.</li><li>compilers are free to inline any function not marked inline.</li><li>compilers are free to use a function calls for functions marked inline.</li><li>should be placed in a header file.</li><li>increases the size of the code.<ul><li>for very small functions in-lining may reduce size.</li></ul></li><li>often the compiler will be able to apply context specific optimizations to code it couldn't do otherwise.</li></ul><pre class="highlight code C++"><span class="c1">//HEADER FILE
</span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;}</span> <span class="c1">//explicit inlining
</span><span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;}</span> <span class="c1">//implicit inlining because this is in a header.</span></pre></div><div class="step step-level-1" step="93" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="139200" data-y="0" data-z="0"><h1 id="use-of-auto">Use of auto</h1><p>There are currently proposals for using auto for function parameters (i.e. that may be in C++17)
Currently you can use auto for the return type.</p><ul><li>Auto can be used as parameters to lambdas in C++14</li><li>Auto is the default return type for a lambda.</li></ul></div><div class="step step-level-1" step="94" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="140800" data-y="0" data-z="0"><h1 id="trailing-return-type">trailing return type</h1><pre class="highlight code C++"><span class="c1">//JUST BECAUSE YOU CAN DO THIS DOESN'T MEAN YOU SHOULD!!!
</span>
<span class="k">auto</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">main</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="95" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="142400" data-y="0" data-z="0"><h1 id="calling-conventions">Calling conventions</h1><pre class="highlight code C++"><span class="c1">//by value
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">//by reference
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">//by const reference
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">//by pointer
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span></pre><div class="notes"><p>Talk about why const ref isn't that valuable for fundamental types but for objects it is a good improvement.</p></div></div><div class="step step-level-1" step="96" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="144000" data-y="0" data-z="0"><h1 id="id11">Calling Conventions</h1><h2 id="from-cppcoreguidelines">From CppCoreGuidelines</h2><img src="images/param-passing-advanced.png" height="500"></img></div><div class="step step-level-1" step="97" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="145600" data-y="0" data-z="0"><h1 id="where-to-define-variables">Where to define variables</h1><p>C89/90 Requires programmers to declare variables "at the top of the function"</p><p><strong>Why you shouldn't do this</strong></p><ul><li>Encourages variable reuse.</li><li>Hard to initialize with reasonable values.</li><li>Item 26 in the Effective C++ says not to do this.</li><li>Often you pay for construction twice. (once to initialize and once to give it a meaningful value)</li><li>Often you may not need to pay for the construction. (return or exception thrown before use)</li></ul></div><div class="step step-level-1" step="98" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="147200" data-y="0" data-z="0"><h1 id="lambda">Lambda</h1><pre class="highlight code C++"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithms&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">uint</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mh">0xDEADBEEF</span><span class="p">,</span> <span class="p">...</span> <span class="p">};</span> <span class="c1">//a bunch of "data";
</span>
    <span class="c1">//LAMBDA TIME!
</span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">uint</span> <span class="n">a</span><span class="p">,</span> <span class="n">uint</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;});</span>

    <span class="c1">//do stuff with your sorted data!
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="99" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="148800" data-y="0" data-z="0"><h1 id="lambda-captures">Lambda Captures</h1><p>I want to use something that is in my local scope...</p><ul><li><tt>[ ]</tt> capture nothing</li><li><tt>[&amp;]</tt> capture anything I use by reference</li><li><tt>[=]</tt> capture anything I use by value</li><li><tt>[x]</tt> capture x by value (value is the default)</li><li><tt>[&amp;y]</tt> capture y by reference</li><li><tt>[x, &amp;y]</tt> capture x by value and y by reference</li><li>By value captures are treated as r-values. (unless lambda is declared mutable.)</li></ul><div class="notes"><p>Specifically ask, "Is there any reason the ones with the variables would be preferable to 2 and 3?".</p><p>The Lambdas project under the Functions solution can show some examples of these in use, but
the next slide covers some stuff that is in that file so tell them you will show examples by wait for now.</p></div></div><div class="step step-level-1" step="100" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="150400" data-y="0" data-z="0"><h1 id="lambda-gotcha">Lambda Gotcha?</h1><p>What does this print?</p><pre class="highlight code C++"><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//important to note this is static (i.e. won't get cleaned up off the stack)
</span>  <span class="k">static</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">return</span> <span class="p">[](){</span><span class="k">return</span> <span class="mi">0</span><span class="p">;};</span> <span class="c1">//return type is auto by default.
</span>    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](){</span><span class="k">return</span> <span class="n">y</span><span class="o">++</span><span class="p">;};</span> <span class="c1">//capture by value
</span>    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">return</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](){</span><span class="k">return</span> <span class="n">y</span><span class="o">++</span><span class="p">;};</span> <span class="c1">//capture by reference
</span>
    <span class="k">default</span><span class="o">:</span> <span class="k">return</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">x</span><span class="p">](){</span><span class="k">return</span> <span class="n">z</span><span class="o">++</span><span class="p">;};</span> <span class="c1">//capture named by reference
</span>  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></pre><div class="notes"><p>static variables can't be captured... It is using the real static variables in the lambda.
<tt>[](){return y++}</tt> would to the same thing.</p></div></div><div class="step step-level-1" step="101" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="152000" data-y="0" data-z="0"><h1 id="storage-classes">Storage Classes</h1><ul><li><strong>Automatic</strong>: All variables defined in a block that aren't one of the others.</li><li><strong>extern</strong>: An object or variable in another translation unit.</li><li><strong>static</strong>: Persist for the lifetime of the program, can be global, namespace, class or local scope<ul><li>static variable retain their state</li></ul></li><li><strong>thread_local</strong>: A variable that is only accessible on the thread which it is created.</li></ul><div class="notes"><p>all lambda captures must be automatic.</p></div></div><div class="step step-level-1" step="102" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="153600" data-y="0" data-z="0"><h1 id="include-functional">#include &lt;functional&gt;</h1><h2 id="lots-of-neat-things-here">Lots of neat things here.</h2><ul><li><tt>std::bind</tt> - creates a function wrapper and lets you "bind" parameters to certain values.</li><li><tt>std::function</tt> - creates a polymorphic function pointer.</li><li>Function objects for doing stuff<ul><li>Arithmetic <tt>plus</tt>, <tt>minus</tt>, <tt>multiplies</tt>, <tt>divides</tt>, <tt>modulus</tt>, <tt>negate</tt></li><li>Comparisons <tt>equal_to</tt>, <tt>not_equal_to</tt>, <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, <tt>less_equal</tt></li><li>Logical <tt>logical_and</tt>, <tt>logical_or</tt>, <tt>logical_not</tt></li><li>Bitwise <tt>bit_and</tt>, <tt>bit_or</tt>, <tt>bit_xor</tt>, <tt>bit_not</tt></li></ul></li></ul><div class="notes"><p>Not really going to talk about the funciton object just know they are there and pretty cool.</p></div></div><div class="step step-level-1" step="103" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="155200" data-y="0" data-z="0"><h1 id="std-bind">std::bind</h1><pre class="highlight code C++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>

<span class="c1">// std::multiplies&lt;int&gt;(a, b) takes two arguments. The transform function can only take one.
// Here we are using multiplies to double each number.
</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">being</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span></pre><div class="notes"><p>what are some other ways we can get the same results?</p><dl><dt>[](int a){</dt><dd><p>return std::multiplies&lt;int&gt;(2, a); }</p></dd></dl><p>Because of this there is really only a difference before C++14. This is because lambdas prior to C++14 are not polymorphic while bind is. I.E. bind is templated and can bind templated parameters so that the bind can be used with different types.</p></div></div><div class="step step-level-1" step="104" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="156800" data-y="0" data-z="0"><h1 id="std-function">std::function</h1><ul><li>Can hold more than functions<ul><li>functors (You don't know what these are yet, although you have used them :) )</li><li>lambdas (really a special case of functors)</li></ul></li><li>Functions don't have the have the exact same signature... Just need to be compatible.</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">foo_functor</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">short</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">fn</span> <span class="o">=</span> <span class="n">foo_functor</span><span class="p">();..</span></pre></div><div class="step step-level-1" step="105" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="158400" data-y="0" data-z="0"><h1 id="building-objects">Building Objects</h1><img src="images/Douglas_McIlroy.jpeg"></img><p>"Those types are not "abstract"; they are as real as <tt>int</tt> and <tt>float</tt>. -- Doug McIlroy</p></div><div class="step step-level-1" step="106" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="160000" data-y="0" data-z="0"><h1 id="structs-and-classes">structs and classes</h1><p>structs and classes are really the same things with slightly different meanings</p><ul><li>a <tt>struct</tt> has a default access-specifier of public</li><li>a <tt>class</tt> has a default access-specifier of private</li></ul><p>So a <tt>struct</tt> and a <tt>class</tt> are functionally equivalent.
<strong>BUT</strong> in real life it is generally accepted that a <tt>struct</tt> is a pile of bits with very little in the way of encapsulation or functionality, while a <tt>class</tt> generally has more intelligence and responsibility. This should become more clear as we look at more examples.</p><div class="notes"><p>This really goes back to C++'s history. People tend to use structs like they would in C and classes for object oriented programming.</p></div></div><div class="step step-level-1" step="107" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="161600" data-y="0" data-z="0"><h1 id="class-basics">Class Basics</h1><ul><li>A class is a user-defined type.</li><li>Consists of a set of members (data and functions).</li><li>Member functions can define the meaning of:<ul><li>initialization (creation)</li><li>copy</li><li>move</li><li>and cleanup (destruction)</li></ul></li><li>Members are accessed using <tt>.</tt> for objects and <tt>-&gt;</tt> for pointers.</li><li>Operators, such as <tt>+</tt>, <tt>!</tt>, and <tt>[]</tt>, can be defined for a class.</li><li>A class is a namespace containing its members.</li><li>The <tt>public</tt> members provide the class interface.</li><li>The <tt>private</tt> members provide the implementation.</li><li>A <tt>struct</tt> is a <tt>class</tt> where members are by default public.</li></ul></div><div class="step step-level-1" step="108" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="163200" data-y="0" data-z="0"><h1 id="a-simple-class">A Simple Class</h1><pre class="highlight code C++"><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>  <span class="c1">// The user interface
</span>      <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">m_</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// A constructor (initializes member m_)
</span>
      <span class="kt">int</span> <span class="n">member_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="c1">// A Member Function
</span>      <span class="p">{</span>
        <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">m_</span><span class="p">;</span>
        <span class="n">m_</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>                  <span class="c1">// sets the new value
</span>        <span class="k">return</span> <span class="n">old</span><span class="p">;</span>              <span class="c1">// returns the old value
</span>      <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>  <span class="c1">// the representation (implementation) is private
</span>      <span class="kt">int</span> <span class="n">m_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">X</span> <span class="n">var</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">user</span><span class="p">(</span><span class="n">X</span> <span class="n">var</span><span class="p">,</span> <span class="n">X</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">member_function</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>  <span class="c1">// Access using . (dot)
</span>    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">member_function</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span> <span class="c1">// Access using -&gt; (arrow)
</span>    <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">var</span><span class="p">.</span><span class="n">m_</span><span class="p">;</span> <span class="c1">// ERROR can't access private member variable.
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="109" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="164800" data-y="0" data-z="0"><h1 id="initialization-methods">Initialization Methods</h1><p>There are four ways to initialize objects in C++11.</p><ul><li>with <tt>()</tt></li><li>with <tt>= (This is not an assignment)</tt></li><li>with <tt>{}</tt></li><li>and with <tt>= {}</tt> (C++ usually, treats this the same as just <tt>{}</tt>)</li><li>List initialization (curly braces <tt>{ }</tt>) is preferred as it does not allow narrowing.</li></ul><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="c1">//if val==7.98, x2 becomes 7 (bad)
</span>    <span class="kt">char</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">val2</span><span class="p">;</span> <span class="c1">//if val2 == 1025, c2 becomes 1 (bad)
</span>    <span class="kt">int</span> <span class="n">x3</span> <span class="p">{</span><span class="n">val</span><span class="p">};</span> <span class="c1">//error: possible truncation (good)
</span>    <span class="kt">char</span> <span class="n">c3</span> <span class="p">{</span><span class="n">val2</span><span class="p">};</span> <span class="c1">//error: possible narrowing (good)
</span>    <span class="kt">char</span> <span class="n">c4</span> <span class="p">{</span><span class="mi">24</span><span class="p">};</span> <span class="c1">//OK: 24 can be represented exactly as a char (good)
</span>    <span class="kt">char</span> <span class="n">c5</span> <span class="p">{</span><span class="mi">264</span><span class="p">};</span> <span class="c1">//Error (assuming 8-bit char): 264 cannot be represented as a char (good)
</span>    <span class="kt">int</span> <span class="n">x4</span> <span class="p">{</span><span class="mf">2.0</span><span class="p">};</span> <span class="c1">//error: no double to int value conversion (good)
</span><span class="p">}</span></pre><div class="notes"><p>Look at Effective Modern C++ Item 7 for more information.</p></div></div><div class="step step-level-1" step="110" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="166400" data-y="0" data-z="0"><h1 id="when-to-not-use-list-initialization">When to not use list initialization</h1><ul><li>With <tt>auto</tt> types<ul><li>When initializing <tt>auto</tt> with braces the deduced type is std::initializer_list</li></ul></li><li>When a constructor of a type takes an std::initializer_list and that isn't what you want.<ul><li>The initializer_list is a more specific match and therefore uses that.</li></ul></li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">);</span>
      <span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
      <span class="p">};</span>

      <span class="n">Widget</span> <span class="nf">w1</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span> <span class="c1">// Calls Widget(int i, bool b);
</span>      <span class="n">Widget</span> <span class="nf">w2</span><span class="p">(</span><span class="n">w1</span><span class="p">);</span> <span class="c1">//Calls copy constructor (not shown)
</span>      <span class="n">Widget</span> <span class="n">w3</span><span class="p">{</span><span class="n">w1</span><span class="p">};</span> <span class="c1">//Calls the copy constructor
</span>      <span class="k">auto</span> <span class="n">w4</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span> <span class="c1">//w4 is now an std::initializer_list unrelated to Widget.
</span>      <span class="k">auto</span> <span class="n">w5</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span> <span class="c1">//w5 will be a Widget initialized with initializer list.
</span>      <span class="k">auto</span> <span class="n">w6</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">//w6 will be a Widget initialized with initializer list.
</span>      <span class="k">auto</span> <span class="n">w7</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">{</span><span class="n">w4</span><span class="p">};</span> <span class="c1">//Copy or move constructor</span></pre><p>}</p><p>note:</p><pre class="highlight ">Do the initialization exercise and go over the results.</pre></div><div class="step step-level-1" step="111" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="168000" data-y="0" data-z="0"><h1 id="construction">Construction</h1><ul><li>A class can have as many constructors as it wants.</li><li>If a class doesn't supply a copy or move constructor the compiler will try to make one for you.<ul><li>If the class is simply a plain old data type then the <tt>default</tt> constructor will be more efficient.</li></ul></li><li>C++11 Defines copy constructors as well as move constructors.<ul><li>Copy constructors are called when the object passed in is an L-Value</li><li>Move constructors are called when the object passed in is an R-Value</li></ul></li><li>A default constructor is one that can be called with no arguments. (In some cases this doesn't make since, so don't give your class one.)</li><li>Constructors can be <tt>default</tt> ed or even <tt>delete</tt> ed.</li></ul></div><div class="step step-level-1" step="112" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="169600" data-y="0" data-z="0"><h1 id="plain-old-data-type-pod">Plain Old Data-Type (POD)</h1><p>C++11 relaxes the rules for PODs and further splits them into two categories.</p><ul><li>Supports static initialization (Trivial Class)</li><li>Same memory layout as a struct compiled in C. (Standard-layout)</li></ul></div><div class="step step-level-1" step="113" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="171200" data-y="0" data-z="0"><h1 id="trivial-classes">Trivial Classes</h1><ul><li>has no non-trivial copy constructors</li><li>has no non-trivial move constructors</li><li>has no non-trivial copy assignment operators</li><li>has no non-trivial move assignment operators</li><li>has a trivial destructor</li></ul><p>Benefits</p><ul><li>static initialization and ok to memcpy</li></ul></div><div class="step step-level-1" step="114" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="172800" data-y="0" data-z="0"><h1 id="trivial-examples">Trivial Examples</h1><pre class="highlight code C++"><span class="k">struct</span> <span class="n">Trivial1</span><span class="p">{};</span> <span class="c1">//empty classes are trivial
</span>
<span class="k">struct</span> <span class="n">Trivial2</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Trivial3</span> <span class="p">:</span> <span class="n">Trivial2</span> <span class="p">{</span>
    <span class="n">Trivial3</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">//not user provided
</span>    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Trivial4</span> <span class="p">{</span> <span class="c1">//no restrictions on access modifiers
</span>    <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">b</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Trivial5</span> <span class="p">{</span>
    <span class="n">Trivial1</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">Trivial2</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">Trivial3</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">Trivial4</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Trivial6</span> <span class="p">{</span>
    <span class="n">Trivial5</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">();</span> <span class="c1">//Its ok to have non-virtual functions.
</span><span class="p">};</span></pre></div><div class="step step-level-1" step="115" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="174400" data-y="0" data-z="0"><h1 id="standard-layout">Standard Layout</h1><p>These are types that are useful for communicating with other languages. This is because they have the same memory layout as a struct or union in C.</p><ul><li>Has no non-static data members of type non-standard-layout class or reference</li><li>Has no virtual functions and no virtual base classes</li><li>Has no non-standard-layout base classes</li><li>Has the same access control for all non-static data members.</li><li>Either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data member</li><li>Has no base classes of the same type as the first non-static data member.</li></ul></div><div class="step step-level-1" step="116" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="176000" data-y="0" data-z="0"><h1 id="standard-layout-examples">Standard Layout Examples</h1><pre class="highlight code C++"><span class="c1">// empty classes have standard-layout
</span><span class="k">struct</span> <span class="n">StandardLayout1</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">StandardLayout2</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">StandardLayout3</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span> <span class="c1">// both are private, so it's ok
</span>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">StandardLayout4</span> <span class="p">:</span> <span class="n">StandardLayout1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">();</span> <span class="c1">// perfectly fine to have non-virtual functions
</span><span class="p">};</span>

<span class="k">struct</span> <span class="nl">StandardLayout5</span> <span class="p">:</span> <span class="n">StandardLayout1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">StandardLayout1</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// can have members of base type if they're not the first
</span><span class="p">};</span>

<span class="k">struct</span> <span class="nl">StandardLayout6</span> <span class="p">:</span> <span class="n">StandardLayout1</span><span class="p">,</span> <span class="n">StandardLayout5</span> <span class="p">{</span>
    <span class="c1">// can use multiple inheritance as long only
</span>    <span class="c1">// one class in the hierarchy has non-static data members
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">StandardLayout7</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">StandardLayout7</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// user-provided ctors are ok
</span><span class="p">};</span></pre></div><div class="step step-level-1" step="117" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="177600" data-y="0" data-z="0"><h1 id="id12">Standard Layout Examples</h1><pre class="highlight code C++"><span class="k">struct</span> <span class="n">StandardLayout8</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">StandardLayout8</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// user-provided ctors are ok
// ok to have non-static data members and other members with different access
</span><span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">StandardLayout9</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">NonStandardLayout1</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// no restrictions on static members
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">NonStandardLayout1</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// cannot have virtual functions
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">NonStandardLayout2</span> <span class="p">{</span>
    <span class="n">NonStandardLayout1</span> <span class="n">X</span><span class="p">;</span> <span class="c1">// has non-standard-layout member
</span><span class="p">};</span>

<span class="k">struct</span> <span class="nl">NonStandardLayout3</span> <span class="p">:</span> <span class="n">StandardLayout1</span> <span class="p">{</span>
    <span class="n">StandardLayout1</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// first member cannot be of the same type as base
</span><span class="p">};</span>

<span class="k">struct</span> <span class="nl">NonStandardLayout4</span> <span class="p">:</span> <span class="n">StandardLayout3</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// more than one class has non-static data members
</span><span class="p">};</span>

<span class="k">struct</span> <span class="nl">NonStandardLayout5</span> <span class="p">:</span> <span class="n">NonStandardLayout3</span> <span class="p">{};</span> <span class="c1">// has a non-standard-layout base class</span></pre></div><div class="step step-level-1" step="118" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="179200" data-y="0" data-z="0"><h1 id="constructors">Constructors</h1><p>Basic constructors are written with the name of the class as a function with no return type.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">//sets x_ to 0
</span>    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//sets x_ to x
</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//Default initialization
</span><span class="p">};</span></pre></div><div class="step step-level-1" step="119" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="180800" data-y="0" data-z="0"><h1 id="initialization-list-in-constructors">Initialization list in constructors</h1><p>What was that funny <tt>: x_(x)</tt> in the previous example. It was an initialization list.</p><p>These initialize your member data and are more efficient than copying them to the stack and then setting the data inside of the constructor. In other words it allows the compiler to do some optimization.</p><p>The order that the member variables appear in the initialization list must be in the same order that they are defined in the class or struct.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">a_</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
                                  <span class="c1">// I skipped b_ but that is ok we are still in order.
</span>                                  <span class="n">c_</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
                                  <span class="n">d_</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">a_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">d_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="120" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="182400" data-y="0" data-z="0"><h1 id="copy-construction">Copy Construction</h1><p>This is a special constructor that allow for a new object to be built from a similar one.</p><pre class="highlight code C++"><span class="n">Class</span> <span class="n">MyClass</span> <span class="p">{</span>
    <span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">//default constructor
</span>
    <span class="c1">//Copy constructor.
</span>    <span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//do what is needed to make a copy}
</span><span class="p">};</span></pre><div class="notes"><p>I specifically say similar here because it is possible to build a base class object from a derived class object so long as the base class isn't pure virtual.</p></div></div><div class="step step-level-1" step="121" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="184000" data-y="0" data-z="0"><h1 id="move-constructor">Move Constructor</h1><p>With C++11 and beyond there is a new type of constructor specifically for R-Values that has the ability to greatly speed up code.
That is the move constructor. Because the object being moved from is a temporary there is no need to keep any of its state valid. This means that pointers to dynamically allocated memory for example can just be moved over and not necessarily the data.</p><pre class="highlight code C++"><span class="n">Class</span> <span class="n">X</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">v_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">X</span><span class="p">()</span><span class="o">:</span><span class="n">v_</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">42</span><span class="p">]),</span> <span class="n">size_</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">X</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">v_</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">.</span><span class="n">size_</span><span class="p">]),</span> <span class="n">size_</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">size_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0U</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
            <span class="n">v_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="n">v_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//copy each element.
</span>    <span class="p">}</span>
    <span class="n">X</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">v_</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">v_</span><span class="p">),</span> <span class="n">size_</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">size_</span><span class="p">)</span> <span class="p">{</span> <span class="n">n</span><span class="p">.</span><span class="n">v_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//Much simplier.
</span>    <span class="o">~</span><span class="n">X</span><span class="p">(){</span><span class="k">if</span><span class="p">(</span><span class="n">v_</span><span class="p">)</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">v_</span><span class="p">;}</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="122" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="185600" data-y="0" data-z="0"><h1 id="delegating-constructor">Delegating Constructor</h1><p>If you want two constructors to do similar things pre-C++11, you could repeat yourself or write an initialization function to preform the common actions.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a_</span><span class="p">;</span>
    <span class="n">validate</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">k_max</span><span class="p">)</span> <span class="n">a_</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="k">else</span> <span class="k">throw</span> <span class="nf">Bad_X</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="n">validate</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
    <span class="n">X</span><span class="p">()</span> <span class="p">{</span><span class="n">validate</span><span class="p">(</span><span class="mi">42</span><span class="p">);}</span>
    <span class="n">X</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">to</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">validate</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
<span class="p">};</span></pre><div class="notes"><p>This is the better of the two options. Copy Pasta is bad because often times one will get a bug fix while the other will be forgotten about. It is just hard to maintain.</p></div></div><div class="step step-level-1" step="123" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="187200" data-y="0" data-z="0"><h1 id="delegating-constructor-cont">Delegating Constructor Cont...</h1><p>In C++11 we can do better with delegating constructors.</p><ul><li>A constructor can not delegate and explicitly initialize a member.</li><li>Delegating by calling another constructor in a constructors member is most likely an error.</li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a_</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">b_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">:</span><span class="n">b_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="o">&lt;</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">k_max</span><span class="p">)</span> <span class="n">a_</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="k">else</span> <span class="k">throw</span> <span class="nf">Bad_X</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
    <span class="n">X</span><span class="p">(</span><span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">X</span><span class="p">{</span><span class="mi">42</span><span class="p">},</span> <span class="n">b_</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// ERROR Can't delegate and explicitly initialize another variable.
</span>
    <span class="c1">// ERROR: This creates a X object with the X(int) constructor inside of the X() constructor
</span>    <span class="c1">// as a temporary on the stack!!!
</span>    <span class="n">X</span><span class="p">()</span> <span class="p">{</span> <span class="n">X</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span> <span class="p">}</span>

    <span class="n">X</span><span class="p">()</span><span class="o">:</span> <span class="n">X</span><span class="p">{</span><span class="mi">42</span><span class="p">}</span> <span class="c1">//GOOD! no problems in C++11.
</span><span class="p">};</span></pre></div><div class="step step-level-1" step="124" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="188800" data-y="0" data-z="0"><h1 id="in-class-initializers">In class Initializers</h1><ul><li>The () operator cannot be used in an in class initializer.
* This is due to how parsing and name lookup occur.</li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a_</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">b_</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">X</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">//initializes a_ to 42
</span>    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">:</span> <span class="n">a_</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{};</span> <span class="c1">//initializes a_ to a instead.
</span><span class="p">};</span></pre></div><div class="step step-level-1" step="125" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="190400" data-y="0" data-z="0"><h1 id="dtor-destructor">DTOR (Destructor)</h1><ul><li>Can automatically generated if you don't need any special clean up.</li><li>Can be used to free memory</li><li>Can be used to free resources</li><li>Likely shouldn't throw exceptions, otherwise:<ul><li>Your object can't be used in standard containers</li><li>A throw will call std::terminate in C++11</li></ul></li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Widget</span><span class="p">()</span> <span class="p">{</span> <span class="n">a_</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Widget</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">a_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">a_</span><span class="p">;</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="126" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="192000" data-y="0" data-z="0"><h1 id="resource-acquisition-is-initialization-raii">Resource Acquisition is Initialization (RAII)</h1><p>One of the more powerful concepts in C++.
This is a C++ technique that ties a resource (memory allocation, threads, sockets, files, database connection) lifetime to the lifetime of an object.</p><ul><li>The constructor acquires the resource.</li><li>The destructor releases the resource.</li></ul></div><div class="step step-level-1" step="127" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="193600" data-y="0" data-z="0"><h1 id="raii-example">RAII Example</h1><pre class="highlight code C++"><span class="k">class</span> <span class="nc">File</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">file_</span> <span class="o">=</span> <span class="n">INVALID_HANDLE</span><span class="p">;</span>
    <span class="n">File</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">){</span>
      <span class="n">file_</span> <span class="o">=</span> <span class="n">openFile</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">File</span><span class="p">()</span> <span class="p">{</span><span class="n">closeFile</span><span class="p">(</span><span class="n">file_</span><span class="p">);}</span>
<span class="p">};</span></pre><div class="notes"><p>This is all made up to be platform agnostic.</p></div></div><div class="step step-level-1" step="128" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="195200" data-y="0" data-z="0"><h1 id="member-functions">Member Functions</h1><p>They really aren't that special other than they have access to all of the member variables.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">z_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">){</span><span class="n">x_</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span> <span class="n">y_</span> <span class="o">+=</span> <span class="n">y</span><span class="p">;</span> <span class="n">z_</span> <span class="o">+=</span> <span class="n">z</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">x_</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">y_</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">z_</span><span class="p">;}</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="129" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="196800" data-y="0" data-z="0"><h1 id="operator-overloading">Operator Overloading</h1><p>To overload operators we use special member functions that start with operator followed by the operator symbol we want to overload.</p><pre class="highlight code C++"><span class="n">Complex</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">r_</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">i_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>

    <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">);</span> <span class="c1">//copy assignment.
</span>    <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Complex</span><span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">);</span> <span class="c1">//move assignment.
</span><span class="p">};</span></pre></div><div class="step step-level-1" step="130" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="198400" data-y="0" data-z="0"><h1 id="generating-default-operations">Generating Default Operations</h1><p>The compiler can and will generate:</p><ul><li>A default constructor: <tt>X()</tt></li><li>A copy constructor: <tt>X(const X&amp;)</tt></li><li>A copy assignment: <tt>X&amp; operator=(const X&amp;)</tt></li><li>A move constructor: <tt>X(X&amp;&amp;)</tt></li><li>A move assignment: <tt>X&amp; operator=(X&amp;&amp;)</tt></li><li>A destructor: <tt>~X()</tt></li></ul><p>By default the compiler will generate each of these if a program uses them. However if the programmer takes control by defining one or more of these operations, the generation of related operations is suppressed.</p><ul><li>declares a constructor for a class, the default is not generated for that class.</li><li>declares a copy operation, a move operation, or a destructor for a class, then no copy operation, move operation, or destructor is generated.</li></ul></div><div class="step step-level-1" step="131" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="200000" data-y="0" data-z="0"><h1 id="default-and-delete">Default and Delete</h1><p>In order to get the suppressed operations back we can use the <tt>default</tt> keyword.
In order to ensure that a operation is not generated we can use the <tt>delete</tt> keyword.</p><pre class="highlight code C++"><span class="c1">//A Class that can only be moved and not copied.
</span><span class="k">class</span> <span class="nc">Thing</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="mi">42</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">a_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Thing</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Thing</span><span class="p">(</span><span class="k">const</span> <span class="n">Thing</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Thing</span><span class="p">(</span><span class="n">Thing</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Thing</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Thing</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Thing</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Thing</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="132" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="201600" data-y="0" data-z="0"><h1 id="rule-of-three">Rule of Three</h1><p>C++ (pre 11) If a class requires a user-defined destructor, a user-defined copy constructor, or a user-defined copy assignment operator, it almost certainly requires all three.</p><p>These special member functions if not specifically defined will be implicity defined by the compiler. The compiler will copy them by value resulting in a shallow copy of pointers, handles and other non-trivially copyable types.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">rule_of_three</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">cstring</span><span class="p">;</span> <span class="c1">// raw pointer used as a handle to a dynamically-allocated memory block
</span> <span class="k">public</span><span class="o">:</span>
    <span class="n">rule_of_three</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">cstring</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// allocate
</span>    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">strcpy</span><span class="p">(</span><span class="n">cstring</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span> <span class="c1">// populate
</span>    <span class="p">}</span>
    <span class="o">~</span><span class="n">rule_of_three</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">cstring</span><span class="p">;</span>  <span class="c1">// deallocate
</span>    <span class="p">}</span>
    <span class="n">rule_of_three</span><span class="p">(</span><span class="k">const</span> <span class="n">rule_of_three</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="c1">// copy constructor
</span>    <span class="p">{</span>
        <span class="n">cstring</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">std</span><span class="o">::</span><span class="n">strcpy</span><span class="p">(</span><span class="n">cstring</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">rule_of_three</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">rule_of_three</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="c1">// copy assignment
</span>    <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">tmp_cstring</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">std</span><span class="o">::</span><span class="n">strcpy</span><span class="p">(</span><span class="n">tmp_cstring</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">);</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">cstring</span><span class="p">;</span>
        <span class="n">cstring</span> <span class="o">=</span> <span class="n">tmp_cstring</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="133" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="203200" data-y="0" data-z="0"><h1 id="rule-of-five">Rule of Five</h1><p>C++ complicates the rule of three because of move constructors and move assignment operators. These must also be added to the list.</p><p>Code too big ... next slide.</p></div><div class="step step-level-1" step="134" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="204800" data-y="0" data-z="0"><pre class="highlight code C++"><span class="k">class</span> <span class="nc">rule_of_five</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">cstring</span><span class="p">;</span> <span class="c1">// raw pointer used as a handle to a dynamically-allocated memory block
</span> <span class="k">public</span><span class="o">:</span>
    <span class="n">rule_of_five</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">cstring</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// allocate
</span>    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">strcpy</span><span class="p">(</span><span class="n">cstring</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span> <span class="c1">// populate
</span>    <span class="p">}</span>
    <span class="o">~</span><span class="n">rule_of_five</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">cstring</span><span class="p">;</span>  <span class="c1">// deallocate
</span>    <span class="p">}</span>
    <span class="n">rule_of_five</span><span class="p">(</span><span class="k">const</span> <span class="n">rule_of_five</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="c1">// copy constructor
</span>    <span class="p">{</span>
        <span class="n">cstring</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">std</span><span class="o">::</span><span class="n">strcpy</span><span class="p">(</span><span class="n">cstring</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">rule_of_five</span><span class="p">(</span><span class="n">rule_of_five</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">cstring</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">)</span> <span class="c1">// move constructor
</span>    <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">cstring</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rule_of_five</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">rule_of_five</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="c1">// copy assignment
</span>    <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">tmp_cstring</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">std</span><span class="o">::</span><span class="n">strcpy</span><span class="p">(</span><span class="n">tmp_cstring</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">);</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">cstring</span><span class="p">;</span>
        <span class="n">cstring</span> <span class="o">=</span> <span class="n">tmp_cstring</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rule_of_five</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">rule_of_five</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="c1">// move assignment
</span>    <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">cstring</span><span class="p">;</span>
        <span class="n">cstring</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">cstring</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">cstring</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="135" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="206400" data-y="0" data-z="0"><h1 id="make-data-members-private">Make Data Members Private</h1><p>This has to do with the ability to maintain an invariance in your types.</p><ul><li>An invariance is defined by the set of valid values for data members.</li><li>Keeping the implementation separate from the design allows for easier refactoring of that implementation in the future.</li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">month_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//valid (00 .. 11)
</span>    <span class="kt">int</span> <span class="n">day_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//valid (00 .. 31)
</span>    <span class="kt">int</span> <span class="n">year_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//valid (00 .. 2050)
</span>
<span class="k">public</span> <span class="o">:</span> <span class="c1">//Things that are public define the interface to the user.
</span>   <span class="n">Date</span><span class="p">()</span> <span class="p">{}</span>
   <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">year</span><span class="p">)</span><span class="o">:</span><span class="n">month_</span><span class="p">(</span><span class="n">month</span><span class="p">),</span> <span class="n">day_</span><span class="p">(</span><span class="n">day</span><span class="p">),</span> <span class="n">year_</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="p">{}</span>

   <span class="kt">int</span> <span class="n">getMonth</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">month_</span><span class="p">;</span> <span class="p">}</span>
   <span class="kt">int</span> <span class="n">getDay</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">day_</span><span class="p">;</span> <span class="p">}</span>
   <span class="kt">int</span> <span class="n">getYear</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">year_</span><span class="p">;</span> <span class="p">}</span>
   <span class="kt">void</span> <span class="n">setYear</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">year_</span> <span class="o">=</span> <span class="n">year</span> <span class="o">&gt;=</span> <span class="mo">00</span> <span class="o">&amp;&amp;</span> <span class="n">year</span> <span class="o">&lt;=</span> <span class="mi">2050</span> <span class="o">?</span> <span class="nl">year</span> <span class="p">:</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Bad Year"</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="kt">void</span> <span class="n">setDay</span><span class="p">(</span><span class="kt">int</span> <span class="n">day</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">day_</span> <span class="o">=</span> <span class="n">day</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">day</span> <span class="o">&lt;=</span> <span class="mi">31</span> <span class="o">?</span> <span class="nl">day</span> <span class="p">:</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Bad Day"</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="kt">void</span> <span class="n">setMonth</span><span class="p">(</span><span class="kt">int</span> <span class="n">month</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">month_</span> <span class="o">=</span> <span class="n">month</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">month</span> <span class="o">&lt;=</span> <span class="mi">31</span> <span class="o">?</span> <span class="nl">month</span> <span class="p">:</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Bad Month"</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">};</span></pre><p>This code doesn't maintain its invariance correctly. How can it be fixed?</p><div class="notes"><p>The constructor for Date allows for invalid values to make it into the objects data members.
By keeping the data members private we can also add things in the future and adapt the type more easily. One such example would be to add the ability to make this object thread safe if we started to use this code in multi-threaded code.</p></div></div><div class="step step-level-1" step="136" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="208000" data-y="0" data-z="0"><h1 id="make-interfaces-that-are-easy-to-use">Make Interfaces That Are Easy To Use</h1><p>The goal is "if an attempted use of an interface won't do what the client expects, the code won't compile; and if the code does compile it will do what the client wants" - Scott Meyer Item 18 Effective C++</p><pre class="highlight code C++"><span class="n">Date</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mo">03</span><span class="p">,</span> <span class="mi">1999</span><span class="p">);</span> <span class="c1">//opps wrong order.
</span><span class="n">Date</span><span class="p">(</span><span class="mo">03</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1999</span><span class="p">);</span></pre><p>One way to prevent client errors is by introducing new types:
* Make Month, Day, Year their own types?</p><blockquote><ul><li>enum class</li><li>structs</li><li>classes</li></ul></blockquote></div><div class="step step-level-1" step="137" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="209600" data-y="0" data-z="0"><h1 id="date">Date</h1><pre class="highlight code C++"><span class="k">struct</span> <span class="n">Day</span> <span class="p">{</span>
    <span class="k">explicit</span> <span class="n">Day</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="n">val_</span><span class="p">{</span><span class="n">d</span><span class="p">}{}</span>
    <span class="kt">int</span> <span class="n">val_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Month</span> <span class="p">{</span>
    <span class="k">explicit</span> <span class="n">Day</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="n">val_</span><span class="p">{</span><span class="n">d</span><span class="p">}{}</span>
    <span class="kt">int</span> <span class="n">val_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Year</span> <span class="p">{</span>
    <span class="k">explicit</span> <span class="n">Day</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="n">val_</span><span class="p">{</span><span class="n">d</span><span class="p">}{}</span>
    <span class="kt">int</span> <span class="n">val_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>
    <span class="n">Day</span> <span class="n">day_</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">Month</span> <span class="n">month_</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">Year</span> <span class="n">year_</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">Date</span><span class="p">(</span><span class="k">const</span> <span class="n">Month</span><span class="o">&amp;</span> <span class="n">month</span><span class="p">,</span> <span class="k">const</span> <span class="n">Day</span><span class="o">&amp;</span> <span class="n">day</span><span class="p">,</span> <span class="k">const</span> <span class="n">Year</span><span class="o">&amp;</span> <span class="n">year</span><span class="p">)</span><span class="o">:</span>
        <span class="n">month_</span><span class="p">{</span><span class="n">month</span><span class="p">},</span> <span class="n">day_</span><span class="p">{</span><span class="n">day</span><span class="p">},</span> <span class="n">year_</span><span class="p">{</span><span class="n">year</span><span class="p">}</span> <span class="p">{}</span>
        <span class="p">...</span>
<span class="p">};</span>

<span class="n">Date</span> <span class="nf">d</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1995</span><span class="p">);</span> <span class="c1">//ERROR wrong types
</span><span class="n">Date</span> <span class="nf">d</span><span class="p">(</span><span class="n">Day</span><span class="p">{</span><span class="mi">30</span><span class="p">},</span> <span class="n">Month</span><span class="p">{</span><span class="mi">3</span><span class="p">},</span> <span class="n">Year</span><span class="p">{</span><span class="mi">1995</span><span class="p">});</span> <span class="c1">//Error, wrong types (cause of order)
</span><span class="n">Date</span> <span class="nf">d</span><span class="p">(</span><span class="n">Month</span><span class="p">{</span><span class="mi">3</span><span class="p">},</span> <span class="n">Day</span><span class="p">{</span><span class="mi">30</span><span class="p">},</span> <span class="n">Year</span><span class="p">{</span><span class="mi">1995</span><span class="p">});</span> <span class="c1">//Works.</span></pre><div class="notes"><p>This could be made better yet if we somehow relate the days, months, and year all together. This way we can correctly check the number of days and on those leap years now if February has 28 or 29 days. For now lets say this check should be done at run time but we may be able to do something with inheritance.</p></div></div><div class="step step-level-1" step="138" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="211200" data-y="0" data-z="0"><h1 id="treat-class-design-as-type-design">Treat Class Design as Type Design</h1><ul><li><dl><dt>How should object of your new type be created and destroyed?</dt><dd><ul><li>How this is done will influence your constructors and destructors.</li><li>This could also involve how you handle memory allocation if you used that.</li></ul></dd></dl></li><li><dl><dt>How should object initialization differ from object assignment?</dt><dd><ul><li>The behavior of constructors compared to assignment will answer this question.</li></ul></dd></dl></li><li>What does it mean for objects of your type to be passed by value?
* Need to consider by value for both R-Values and L-Values.
* This means both the copy and move constructors</li><li>What are the restrictions on legal values for your new types?
* Usually, only some values of a class's data members are valid.
* The combination of valid values defines the invariance that your class will have to maintain</li><li>What standard functions should be disallowed?
* Those should be deleted (C++11 and beyond), or made private (pre C++11)</li><li>Who should have access to the members of your new type?
* This determines friendships and which members are public, protected, or private as well as whether or not to nest a class inside another.</li><li>How general is your new type?
* Perhaps it would be better as a template?</li></ul></div><div class="step step-level-1" step="139" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="212800" data-y="0" data-z="0"><h1 id="the-end">The End</h1></div><div class="step step-level-1" step="140" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="214400" data-y="0" data-z="0"><h1 id="object-inheritance-and-polymorphism">Object Inheritance and Polymorphism</h1><img src="images/stdExceptions.png"></img><p>Abstraction is a selective ignorance. -- Andrew Koenig</p><div class="notes"><p>The image is taken from The C++ Standard Library: A Tutorial and Reference (2nd Edition).</p></div></div><div class="step step-level-1" step="141" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="216000" data-y="0" data-z="0"><h1 id="introduction">Introduction</h1><p>The primary focus of this section is to outline some design techniques, rather than just language features. Designs of class hierarchies can often be a good way of simplifying a complex problem. Computer Science heavily utilizes abstractions to solve real problems and inheritance is one type of abstraction mechanism provided by C++.</p><p>Hierarchies offer two kinds of benefits</p><ul><li>Interface inheritance: Provides a contract that can allow for various types to be derived and access through.</li><li>Implementation inheritance: Simplifies the implementation of derived classes.</li></ul></div><div class="step step-level-1" step="142" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="217600" data-y="0" data-z="0"><h1 id="implementation-of-inheritance">Implementation of Inheritance</h1><pre class="highlight code C++"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">"timepoint.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first_name_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">last_name_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">birthday_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">last_name</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Person</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">setBirthday</span><span class="p">(</span><span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mon</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hour</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getBirthday</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getFirstName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getLastName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="143" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="219200" data-y="0" data-z="0"><h1 id="id13">Implementation of Inheritance</h1><pre class="highlight code C++"><span class="cp">#include</span> <span class="cpf">"Person.h"</span><span class="cp">
</span><span class="k">class</span> <span class="nc">Employee</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">Person</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">employeeNumber_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Employee</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="n">employeeNumber</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Employee</span><span class="p">();</span>

    <span class="kt">int</span> <span class="nf">getEmployeeNumber</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">getEmployeeNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="144" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="220800" data-y="0" data-z="0"><h1 id="id14">Implementation of Inheritance</h1><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">printPeople</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">person</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Person</span> <span class="n">me</span><span class="p">(</span><span class="s">"Jeff"</span><span class="p">,</span> <span class="s">"Scaparra"</span><span class="p">);</span>
    <span class="n">me</span><span class="p">.</span><span class="n">setBirthday</span><span class="p">(</span><span class="mi">1984</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">34</span><span class="p">);</span>

    <span class="n">printPeople</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>

    <span class="n">Employee</span> <span class="n">aaron</span><span class="p">(</span><span class="s">"Aaron"</span><span class="p">,</span> <span class="s">"Bray"</span><span class="p">,</span> <span class="mi">42</span> <span class="p">);</span>
    <span class="n">aaron</span><span class="p">.</span><span class="n">setBirthday</span><span class="p">(</span><span class="mi">1987</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>

    <span class="n">printPeople</span><span class="p">(</span><span class="n">aaron</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="145" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="222400" data-y="0" data-z="0"><h1 id="access-controls">Access Controls</h1><ul><li><em>private</em>: can only be accessed by member functions and friends of the class</li><li><em>protected</em>: can only be acceess by member functions and freidns of the class and of derived classes.</li><li><em>public</em>: its name can be used by any function</li></ul><img src="images/accessControl.png"></img></div><div class="step step-level-1" step="146" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="224000" data-y="0" data-z="0"><h1 id="inheritance-types">Inheritance Types</h1><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Employee</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">Person</span>
<span class="p">{</span></pre><ul><li>public</li><li>private</li><li>virtual</li></ul></div><div class="step step-level-1" step="147" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="225600" data-y="0" data-z="0"><h1 id="is-a-inheritance">Is-A Inheritance</h1><p>Public inheritance is "Is-A" Inheritance. In the previous example:</p><ul><li>an Employee object could be used where a Person was because an Employee is a Person.</li><li>a Person could <em>NOT</em> be used where an Employee was because not all Persons are Employees.</li></ul><p>This sounds simple but can be problematic.</p></div><div class="step step-level-1" step="148" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="227200" data-y="0" data-z="0"><h1 id="id15">Is-A Inheritance</h1><p>Can a penguin fly?</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Bird</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span></pre><div class="notes"><p>This example is taken from Item 32 of Effective C++
Now we have a problem. This hierarchy says that penguins can fly, which we know is not true.
There are a few ways to fix this problem</p><ul><li>If your application doesn't need birds to fly (Maybe you only care about beaks and wings) then you can remove fly and get on with your life.</li><li>You could a Bird base class without fly and derive a FlyingBird class from that for flying birds and use the base Bird for non-flying birds.</li><li>You could override fly and have it be a run-time error for Penguin.</li></ul></div></div><div class="step step-level-1" step="149" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="228800" data-y="0" data-z="0"><h1 id="id16">Is-A Inheritance</h1><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Bird</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FlyingBird</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="150" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="230400" data-y="0" data-z="0"><h1 id="id17">Is-A Inheritance</h1><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Bird</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">()</span> <span class="p">{</span><span class="n">error</span><span class="p">(</span><span class="s">"Attempt to make a penguin fly!"</span><span class="p">);}</span>
    <span class="p">....</span>
<span class="p">};</span></pre><p>Which way is better?</p><pre class="highlight code C++"><span class="n">Penguin</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">fly</span><span class="p">();</span></pre><div class="notes"><p>C++</p><p>In most cases you should prefer compiler errors over runtime errors.</p></div></div><div class="step step-level-1" step="151" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="232000" data-y="0" data-z="0"><h1 id="virtual">Virtual</h1><p>Virtual functions allow for polymorphism. When we say a function is virtual this means that it can be overridden by a derived class.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::foo</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::bar</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">foobar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foobar::foo</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foobar::bar</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foobar</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">Base</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">Base</span><span class="o">&amp;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="n">a</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span> <span class="c1">//foobar::foo
</span>    <span class="n">b</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span> <span class="c1">//Base::foo
</span>    <span class="n">c</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span> <span class="c1">//Base::foo
</span>    <span class="n">a</span><span class="p">.</span><span class="n">bar</span><span class="p">();</span> <span class="c1">//foobar::bar
</span>    <span class="n">b</span><span class="p">.</span><span class="n">bar</span><span class="p">();</span> <span class="c1">//Base::bar
</span>    <span class="n">c</span><span class="p">.</span><span class="n">bar</span><span class="p">();</span> <span class="c1">//foobar::bar
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="152" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="233600" data-y="0" data-z="0"><h1 id="id18">Virtual</h1><ul><li>Functions that <tt>override</tt> a <tt>virtual</tt> function become <tt>virtual</tt> and don't have to be declared <tt>virtual</tt></li><li>To be explicit that your overriding a <tt>virtual</tt> function use the <tt>override</tt> keyword</li><li>To get polymorphic behavior objects must be accessed through a pointer or reference</li><li><tt>virtual</tt> functions work through a virtual function table</li><li>Use <tt>final</tt> to describe a virtual function that shouldn't be <tt>override</tt> by another object.</li></ul><h2 id="use-virtual">Use Virtual</h2><ul><li>When defining and interface</li><li>When we want derived classes to be able to change the function</li></ul></div><div class="step step-level-1" step="153" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="235200" data-y="0" data-z="0"><h1 id="override">override</h1><ul><li>Note that override can do multiple things<ul><li>Protects against typos</li><li>Makes it clear that a function is virtual</li><li>Clarifies a programmers intent</li></ul></li><li><tt>override</tt> is not a keyword; it is a contextual keyword<ul><li>Please don't be clever and use override for variable names. This was done for backwards compatibility not for modern use.</li></ul></li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">makeMoney</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//This class should be marked as a defect in a code review.
</span><span class="k">class</span> <span class="nc">foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// A Typo (I forgot it was makeMoney)
</span>  <span class="kt">int</span> <span class="n">getMoney</span><span class="p">();</span> <span class="c1">//This doesn't override makeMoney but the programmer gets no error
</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">bar</span><span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
<span class="kt">int</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//Showing that override can be used elsewhere.
</span><span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">getMoney</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//ERROR!!!
</span>  <span class="c1">//After getting the compiler error I fix the code
</span>  <span class="kt">int</span> <span class="nf">makeMoney</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//clearly shows intent, OK!
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="154" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="236800" data-y="0" data-z="0"><h1 id="final">final</h1><p>In the rare case where we inherit from a virtual base class and answer no to:</p><ul><li>Can we imagine the need for further derived classes?</li><li>Does a designer of a derived class need to redefine the function to achieve a plausible aim?</li><li>Is correctly overriding a function straightforward.</li></ul><p>After using final any attempt to override is an error.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">X</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">final</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Y</span> <span class="o">:</span> <span class="k">public</span> <span class="n">X</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//ERROR
</span><span class="p">};</span></pre><ul><li>If the class should never be derived from we can apply the final keyword to the whole class</li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">X</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">//overrides and is final
</span><span class="p">};</span></pre><div class="notes"><p>One reason people use final is because of the optimization that it allows the compiler to do in some unique situations. (I.E. passing pointers or references to the Derived Class can be optimized away.)</p></div></div><div class="step step-level-1" step="155" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="238400" data-y="0" data-z="0"><h1 id="abstract-class-interface">Abstract Class (Interface)</h1><p>This is another use for virtual where we don't provide a default implementation and these functions are known as pure virtual.</p><h2 id="classes-with-pure-virtual-functions">Classes with pure virtual functions:</h2><ul><li>Cannot be instantiated.</li><li>Can be used as pointers to store derived classes.</li><li>Is how we construct interfaces in C++</li></ul><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Slogan</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">slogan</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// A pure virtual function
</span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Trump</span> <span class="o">:</span> <span class="n">Slogan</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">slogan</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"Make America Great Again!"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Clinton</span> <span class="o">:</span> <span class="n">Slogan</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">slogan</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"Hillary for America"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span></pre><div class="notes"><p>Slogans taken from
* <a href="http://presidential-candidates.insidegov.com/stories/6557/campaign-slogans-presidential-candidate#5-Hillary-Clinton-Democrat">http://presidential-candidates.insidegov.com/stories/6557/campaign-slogans-presidential-candidate#5-Hillary-Clinton-Democrat</a>
* <a href="http://presidential-candidates.insidegov.com/stories/6557/campaign-slogans-presidential-candidate#20-Donald-Trump-Republican">http://presidential-candidates.insidegov.com/stories/6557/campaign-slogans-presidential-candidate#20-Donald-Trump-Republican</a></p></div></div><div class="step step-level-1" step="156" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="240000" data-y="0" data-z="0"><h1 id="construction-and-destruction">Construction and Destruction</h1><p>When we derive objects we often want to call the constructors of the base classes.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Base</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">x_</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base DTOR</span><span class="se">\n</span><span class="s">"</span><span class="p">;}</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">y_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Derived</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">Base</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y_</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Base</span> <span class="n">b1</span><span class="p">;</span>
    <span class="n">Derived</span> <span class="n">d1</span><span class="p">;</span>
<span class="p">}</span></pre><div class="notes"><p>Show in VS2015</p></div></div><div class="step step-level-1" step="157" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="241600" data-y="0" data-z="0"><h1 id="inheriting-constructors">Inheriting Constructors</h1><p>std::vector doesn't guarantee range checking. If I want to have all the same functionality as std::vector I may do something like:</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Vector</span> <span class="p">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span> <span class="c1">// use vector's size type
</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);}</span> <span class="c1">//use checked access
</span>    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)};</span>
<span class="p">}</span>

<span class="n">Vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="c1">//Error no initializer constructor</span></pre><p>We don't inherit the constructors for Vector this way... :(</p></div><div class="step step-level-1" step="158" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="243200" data-y="0" data-z="0"><h1 id="id19">Inheriting Constructors</h1><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Vector</span> <span class="p">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span> <span class="c1">// use vector's size type
</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">vector</span> <span class="c1">//inherit vectors constructors
</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);}</span> <span class="c1">//use checked access
</span>    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)};</span>
<span class="p">}</span>

<span class="n">Vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="c1">//OK uses std::vector initializer-list constructor.</span></pre></div><div class="step step-level-1" step="159" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="244800" data-y="0" data-z="0"><h1 id="id20">Inheriting Constructors</h1><p>They can be problematic if you define new member variables that need explicit initialization.</p><pre class="highlight code C++"><span class="k">struct</span> <span class="n">B1</span> <span class="p">{</span>
    <span class="n">B1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">D1</span> <span class="p">:</span> <span class="n">B1</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">B1</span><span class="o">::</span><span class="n">B1</span><span class="p">;</span> <span class="c1">// implicitly declares D1(int)
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//string has a default constructor
</span>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//we "forgot" to provide for initialization of x
</span><span class="p">}</span>

<span class="k">struct</span> <span class="nl">D2</span> <span class="p">:</span> <span class="n">B1</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">B1</span><span class="o">::</span><span class="n">B1</span><span class="p">;</span> <span class="c1">// implicitly declares D1(int)
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="c1">//string has a default constructor
</span>    <span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">//x is initialized
</span><span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">D1</span> <span class="n">d1a</span><span class="p">{</span><span class="mi">6</span><span class="p">};</span> <span class="c1">//d1a.x not initialized
</span>    <span class="n">D1</span> <span class="n">d1b</span><span class="p">;</span> <span class="c1">//ERROR no default constructor
</span>    <span class="n">D2</span> <span class="n">d2a</span><span class="p">{</span><span class="mi">6</span><span class="p">};</span> <span class="c1">//ok d2a.x is 0;
</span>    <span class="n">D2</span> <span class="n">d2b</span><span class="p">;</span> <span class="c1">//Still an Error
</span><span class="p">}</span></pre><p>It is usually best to avoid being clever and restrict the use of inheriting constructors to times where you don't add any data members.</p></div><div class="step step-level-1" step="160" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="246400" data-y="0" data-z="0"><h1 id="multiple-inheritance">Multiple Inheritance</h1><pre class="highlight code c++"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">eat</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Mammal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">breathe</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">WingedAnimal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">flap</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// A bat is a winged mammal
</span><span class="k">class</span> <span class="nc">Bat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mammal</span><span class="p">,</span> <span class="k">public</span> <span class="n">WingedAnimal</span> <span class="p">{</span>
<span class="p">};</span>

<span class="n">Bat</span> <span class="n">bat</span><span class="p">;</span></pre></div><div class="step step-level-1" step="161" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="248000" data-y="0" data-z="0"><h1 id="diamond-pattern">Diamond Pattern</h1><p>The code in the previous slide outlines a problem.
If we want to call bat.eat(); both of of base classes have an eat that they inherited from Animal.
Which do we call?</p><p>We could disambiguate:</p><pre class="highlight code c++"><span class="n">Bat</span> <span class="n">b</span><span class="p">;</span>
<span class="n">Animal</span> <span class="o">&amp;</span><span class="n">mammal</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Mammal</span><span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">Animal</span> <span class="o">&amp;</span><span class="n">winged</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">WingedAnimal</span><span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">mammal</span><span class="p">.</span><span class="n">eat</span><span class="p">();</span>
<span class="n">winged</span><span class="p">.</span><span class="n">eat</span><span class="p">();</span></pre></div><div class="step step-level-1" step="162" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="249600" data-y="0" data-z="0"><h1 id="id21">Diamond Pattern</h1><p>A better solution is to use virtual inheritance which will guarantee that we only have one Animal class.</p><pre class="highlight code c++"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">eat</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Mammal</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">breathe</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">WingedAnimal</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">flap</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// A bat is a winged mammal
</span><span class="k">class</span> <span class="nc">Bat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mammal</span><span class="p">,</span> <span class="k">public</span> <span class="n">WingedAnimal</span> <span class="p">{</span>
<span class="p">};</span>

<span class="n">Bat</span> <span class="n">bat</span><span class="p">;</span></pre><p>The animal portion of Bat::WingedAnimal and Bat::Mammal is now the same.</p></div><div class="step step-level-1" step="163" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="251200" data-y="0" data-z="0"><h1 id="id22">The END</h1></div><div class="step step-level-1" step="164" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="252800" data-y="0" data-z="0"><h1 id="error-handling">Error Handling</h1><p>&#x201C;Don't interrupt me while I'm interrupting."
&#x2015; Winston S. Churchill</p></div><div class="step step-level-1" step="165" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="254400" data-y="0" data-z="0"><h1 id="outline">Outline</h1><p>Mostly we will be looking at Exception Handling.</p><ul><li>What is an exception<ul><li>try catch</li><li>throw</li><li>exception guarantees</li></ul></li><li>RAII and scopeguard</li><li>Traditional Error Handling</li></ul></div><div class="step step-level-1" step="166" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="256000" data-y="0" data-z="0"><h1 id="id23">Introduction</h1><p>Will we focus on the use of exceptions for errors that can't be handled locally.
I will refer to "a library" as any code that is invoked to preform a task.</p><ul><li>A library is just normal code, but often the writer doesn't know how their code will be used.</li><li>The Author of a library can often detect a run-time error but does not in general have any idea what to do about it.</li><li>The User of a library may know how to deal with an error but can't easily detect it.</li></ul><pre class="highlight code c++"><span class="kt">void</span> <span class="nf">taskmaster</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span><span class="p">{</span>
      <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">do_task</span><span class="p">();</span>
      <span class="c1">//use result;
</span>    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="n">Some_Error</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//Failure to do_task: Handle Problem.
</span>    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_task</span><span class="p">(){</span>
    <span class="c1">//..do something
</span>    <span class="k">if</span><span class="p">(</span><span class="cm">/*could preform task*/</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">throw</span> <span class="n">Some_Error</span><span class="p">{};</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="167" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="257600" data-y="0" data-z="0"><h1 id="traditional-approaches">Traditional Approaches</h1><ul><li><strong>Terminate the Program</strong>: pretty drastic approach and often we can do better</li></ul><pre class="highlight code c++"><span class="k">if</span><span class="p">(</span><span class="n">something_wrong</span><span class="p">)</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span></pre><ul><li><strong>Return an error value</strong>: Not always feasible. Very much C style.</li></ul><pre class="highlight code c++"><span class="kt">int</span> <span class="nf">getInt</span><span class="p">();</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">getInt</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">);</span></pre><ul><li><strong>Return a legal value and leave the program in an ""error state.""</strong><ul><li>many C library functions set the nonlocal variable errno to indicate an error.</li><li>Easy to forget to check.</li></ul></li><li><strong>Call an error-handler functino</strong><ul><li>Unless error-handler can fully handle the error likely still should call terminate.</li></ul></li></ul><pre class="highlight code c++"><span class="k">if</span><span class="p">(</span><span class="n">something_wrong</span><span class="p">)</span> <span class="n">something_handler</span><span class="p">();</span></pre></div><div class="step step-level-1" step="168" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="259200" data-y="0" data-z="0"><h1 id="exceptions-default-to-terminate">Exceptions Default to Terminate</h1><ul><li>Unhanded errors call terminate</li><li>Exception handling makes programs more "brittle"<ul><li>This sounds bad but has some advantages.</li><li>Preferable to getting wrong results later in the development process or after release.</li><li>We can catch all exceptions when termination is unacceptable.</li></ul></li></ul></div><div class="step step-level-1" step="169" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="260800" data-y="0" data-z="0"><h1 id="hierarchical-error-handling">Hierarchical Error Handling</h1><ul><li>Successful fault-tolerant systems are multi-level<ul><li>Each level copes with as many errors as it can without getting too contorted.</li><li>Not every function should be a firewall.</li><li>Leaves exceptions for higher levels if the current level can't deal with them</li></ul></li><li>This will be better understood when doing todays lab.</li></ul></div><div class="step step-level-1" step="170" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="262400" data-y="0" data-z="0"><img src="images/showCode.jpg"></img></div><div class="step step-level-1" step="171" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="264000" data-y="0" data-z="0"><h1 id="catching-exceptions">Catching Exceptions</h1><pre class="highlight code c++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="c1">//do stuff
</span>    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">){</span>
       <span class="c1">//Handle Runtime Error
</span>    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">){</span>
       <span class="c1">//Handle every standard-library exception
</span>    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(...){</span>
       <span class="c1">//Handle anything.. but you don't know what it is. :(
</span>    <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="172" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="265600" data-y="0" data-z="0"><h1 id="id24">Catching Exceptions</h1><p>The more specific handlers get bypassed.</p><pre class="highlight code c++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="c1">//do stuff
</span>    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(...){</span>
       <span class="c1">//Handle anything.. but you don't know what it is. :(
</span>    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">){</span>
       <span class="c1">//Handle Generic std::exception
</span>    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">){</span>
       <span class="c1">//Handle Runtime Error
</span>    <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="173" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="267200" data-y="0" data-z="0"><h1 id="exceptions-in-std">Exceptions in std::</h1><img src="images/stdExceptions.png"></img></div><div class="step step-level-1" step="174" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="268800" data-y="0" data-z="0"><h1 id="function-try-block">Function-try-block</h1><ul><li>Primarily used for logging.</li><li>Can't access members of the class or of a base.</li><li>Every catch-clause in the function must terminate by throwing.</li></ul><pre class="highlight code c++"><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">S</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="k">try</span> <span class="o">:</span> <span class="n">m</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"constructed, mn = "</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"arg="</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="s">" failed: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// implicit throw; here
</span><span class="p">};</span></pre></div><div class="step step-level-1" step="175" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="270400" data-y="0" data-z="0"><h1 id="rethrowing-exceptions">Rethrowing Exceptions</h1><p>I can't fully clean up but I want to do something.</p><pre class="highlight code c++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="c1">//do stuff
</span>    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">){</span>
       <span class="c1">//Partially Handle Runtime Error
</span>       <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"DEBUG ME!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
       <span class="k">throw</span><span class="p">;</span> <span class="c1">//Rethrows the same exception.
</span>    <span class="p">}</span></pre></div><div class="step step-level-1" step="176" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="272000" data-y="0" data-z="0"><h1 id="throwing-exceptions">Throwing exceptions</h1><p>Is Easy</p><pre class="highlight code c++"><span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//... do stuff
</span>    <span class="k">if</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Weeee!"</span><span class="p">);</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="177" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="273600" data-y="0" data-z="0"><h1 id="creating-your-own-exceptions">Creating your own exceptions</h1><h2 id="you-can-literally-throw-anything">You can literally throw anything.</h2><pre class="highlight code c++"><span class="k">try</span><span class="p">{</span>
    <span class="k">throw</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">){</span>
<span class="c1">// process int
</span><span class="p">}</span></pre><h2 id="but-you-shouldn-t">But you shouldn't.</h2></div><div class="step step-level-1" step="178" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="275200" data-y="0" data-z="0"><h1 id="ok-how-to-really-create-your-own-exceptions">OK How to REALLY create your own exceptions</h1><p>Derive from one of the sub-classes of <tt>std::exception</tt> in <tt>&lt;stdexcept&gt;</tt></p><pre class="highlight code c++"><span class="k">struct</span> <span class="nl">BadFile</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">{</span>
    <span class="n">BadFile</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">what</span><span class="p">)</span><span class="o">:</span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="n">what</span><span class="p">){}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">throw</span> <span class="n">BadFile</span><span class="p">(</span><span class="s">"This File is Bad"</span><span class="p">);</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="179" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="276800" data-y="0" data-z="0"><h1 id="id25">The End</h1></div><div class="step step-level-1" step="180" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="278400" data-y="0" data-z="0"><h1 id="templates">Templates</h1><h2 id="building-programs-that-the-compiler-runs">Building programs that the compiler runs!</h2><img src="images/Templates.png"></img></div><div class="step step-level-1" step="181" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="280000" data-y="0" data-z="0"><h1 id="id26">Templates</h1><p>Templates are how we achieve generic programming in C++.</p><ul><li>Templates allow a straightforward way to represent a wide range of general concepts and simple ways to combine them.</li><li>The template mechanism allows a type or a value to be a parameter in the definition of a class, a function, or a type alias.</li><li>Every major standard-library abstraction is represented as a template<ul><li>ostream, list, map, unique_ptr, function, ...</li></ul></li></ul></div><div class="step step-level-1" step="182" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="281600" data-y="0" data-z="0"><h1 id="defining-a-template">Defining a template</h1><p>As a function:</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">foo</span><span class="p">(</span> <span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="183" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="283200" data-y="0" data-z="0"><h1 id="as-a-class">As a class</h1><ul><li>A class generated from a template is an ordinary class</li><li>There is no run-time mechanism or overhead</li></ul><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
    <span class="n">T</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="n">array_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
      <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span></pre></div><div class="step step-level-1" step="184" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="284800" data-y="0" data-z="0"><h1 id="instantiation-of-templates">Instantiation of Templates</h1><p>For classes we almost always supply template arguments.</p><pre class="highlight code C++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//typedef basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt; &gt; string;</span></pre><p>For functions we sometimes supply template arguments.</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">to</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">num</span><span class="p">;</span>
    <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">num1</span><span class="p">,</span> <span class="n">T</span> <span class="n">num2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">num</span> <span class="o">=</span> <span class="n">to</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"924"</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"924"</span><span class="p">,</span> <span class="s">"is a number"</span><span class="p">);</span> <span class="c1">//Even tho is isn't required we can still provide the arguments.</span></pre></div><div class="step step-level-1" step="185" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="286400" data-y="0" data-z="0"><h1 id="type-equivalence">Type Equivalence</h1><p>It is important to understand how templates view types because for every new type use the compiler will generate a new version.</p><ul><li>Aliases do not introduce a new type</li></ul><pre class="highlight code C++"><span class="k">using</span> <span class="n">uint</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//same type as a.</span></pre><ul><li>Unsigned v. signed ARE different types.</li><li>The compiler can evaluate constexpr (constant expressions)<blockquote><ul><li>so <tt>Buffer&lt;char, 20-10&gt;</tt> will be the same type as <tt>Buffer&lt;char, 10&gt;</tt></li></ul></blockquote></li><li>Types generated by a single template with different arguments are different types.</li></ul></div><div class="step step-level-1" step="186" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="288000" data-y="0" data-z="0"><h1 id="errors">Errors</h1><p>Errors relating to template parameters cannot be detected until the template is used.</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Elem</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elem</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">container</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecInt</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">push_back</span><span class="p">(</span><span class="n">vecInt</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">//FINE.
</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">//ERROR "left of .push_back must have class/struct/union"</span></pre></div><div class="step step-level-1" step="187" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="289600" data-y="0" data-z="0"><h1 id="type-checking">Type Checking</h1><p>There is currently no way to implement requirements on template parameters.</p><pre class="highlight code C++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">Container</span> <span class="n">Cont</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Elem</span><span class="o">&gt;</span>
    <span class="n">requires</span> <span class="n">Equal_comparable</span><span class="o">&lt;</span><span class="n">Cont</span><span class="o">::</span><span class="n">value_type</span><span class="p">,</span> <span class="n">Elem</span><span class="o">&gt;</span><span class="p">()</span>
<span class="kt">int</span> <span class="n">find_index</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Elem</span> <span class="n">e</span><span class="p">);</span></pre><ul><li>This is the idea behind the concepts proposal that hasn't made it into the standard yet.</li></ul></div><div class="step step-level-1" step="188" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="291200" data-y="0" data-z="0"><h1 id="static-assert">static_assert</h1><p>static_assert allowing for better error messages.</p><ul><li>static_assert is a compile time assert.</li><li>if false the message in the assert will appear as a compiler error</li></ul><pre class="highlight code">template&lt;typename Cont, typename Elem&gt;
void push_back(Cont&amp; container, const Elem&amp; elem)
{
    static_assert(std::is_class&lt;Cont&gt;::value, "Cont must be a class");
    container.push_back(elem);
}

...
push_back(num, 5); //ERROR: Cont must be a class</pre></div><div class="step step-level-1" step="189" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="292800" data-y="0" data-z="0"><h1 id="member-templates">Member templates</h1><p>A template or non-template class can have templated member functions.</p><pre class="highlight code C++"><span class="k">class</span> <span class="nc">foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count_</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></pre></div><div class="step step-level-1" step="190" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="294400" data-y="0" data-z="0"><h1 id="overloading-function-templates">Overloading Function Templates</h1><ul><li>overload resolution will be needed to deduce the proper function call</li><li>The most specialize function will be called.</li></ul><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">foo</span><span class="p">(</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element2</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">foo</span><span class="p">(</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">elem2</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">element1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">elem2</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">elem1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">elem2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FooBar</span><span class="o">&gt;</span> <span class="n">foobars</span><span class="p">;</span>
<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//int foo(int, int);
</span><span class="n">foo</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//T foo(const T&amp;, int);
</span><span class="n">foo</span><span class="p">(</span><span class="n">foobars</span><span class="p">,</span> <span class="n">FooBar</span><span class="p">());</span> <span class="c1">//std::vector&lt;T&gt; foo(const std::vector&lt;T&gt;&amp;, const T&amp;);
</span><span class="n">foo</span><span class="p">(</span><span class="mf">2.3</span><span class="p">,</span> <span class="mi">2LL</span><span class="p">);</span> <span class="c1">//T foo(const T&amp;, const T&amp;);
</span><span class="n">foo</span><span class="p">(</span><span class="sc">'c'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></pre></div><div class="step step-level-1" step="191" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="296000" data-y="0" data-z="0"><h1 id="function-template-deduction">Function template deduction</h1><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">max</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">k</span><span class="p">(){</span>
    <span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//max&lt;int&gt;(1,2)
</span>    <span class="n">max</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">);</span> <span class="c1">//max&lt;char&gt;('a', 'b')
</span>    <span class="n">max</span><span class="p">(</span><span class="mf">2.7</span><span class="p">,</span> <span class="mf">4.9</span><span class="p">);</span> <span class="c1">//max&lt;double&gt;(2.7, 4.9)
</span>    <span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span> <span class="c1">//max&lt;int&gt;(int{s}, 7) (trivial conversion used)
</span>
    <span class="n">max</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//error: ambiguous: max&lt;char, char&gt;() or max&lt;int, int&gt;()?
</span>    <span class="n">max</span><span class="p">(</span><span class="mf">2.7</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//error: ambiguous: max&lt;double, double&gt;() or max&lt;int, int&gt;()?
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="192" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="297600" data-y="0" data-z="0"><h1 id="argument-substitution-failure">Argument Substitution Failure.</h1><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">itr</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">itr</span><span class="o">::</span><span class="n">value_type</span> <span class="n">mean</span><span class="p">(</span><span class="n">itr</span> <span class="n">first</span><span class="p">,</span> <span class="n">itr</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">typename</span> <span class="n">itr</span><span class="o">::</span><span class="n">value_type</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">+=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tmp</span> <span class="o">/</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNums</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">arrayNums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span> <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The mean of vecNums is "</span> <span class="o">&lt;&lt;</span> <span class="n">mean</span><span class="p">(</span><span class="n">vecNums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecNums</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">//int* doesn't have a member called value type.
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"the mean of arrayNums is "</span> <span class="o">&lt;&lt;</span> <span class="n">mean</span><span class="p">(</span><span class="n">arrayNums</span><span class="p">,</span> <span class="n">arrayNums</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="193" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="299200" data-y="0" data-z="0"><h1 id="sfinae">SFINAE</h1><h2 id="substitution-failure-is-not-an-error">Substitution Failure Is Not An Error</h2><p>In the previous example the call to <tt>mean</tt> with pointers passed in failed because there is no such thing as a <tt>int*::value_type</tt>. However, what if we defined another mean.</p><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">mean</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">last</span><span class="p">){</span>
    <span class="n">T</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">ptr</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">+=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tmp</span> <span class="o">/</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">);</span>
<span class="p">}</span></pre><p>This works even though the first definition of mean fails. That is because the language has a rule that states that <strong>substitution failure</strong> is not an error. It simply causes that template to be ignored; that is, the template does not contribute a specialization to the overload set.</p><p>Without the SFINAE rule we would get compile-time errors even when error-free alternatives exist.</p></div><div class="step step-level-1" step="194" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="300800" data-y="0" data-z="0"><h1 id="concept-like">Concept-like</h1><p>Concepts are a C++ feature that will be coming some time in the future that will allow us to be more granular in our allowed template parameters. Until they arrive we have to rely on template metaprograms to achieve the same effect. ..</p></div><div class="step step-level-1" step="195" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="302400" data-y="0" data-z="0"><h1 id="working-with-dynamic-memory">Working with Dynamic Memory</h1><h2 id="using-new-and-delete">Using <tt>new</tt> and <tt>delete</tt></h2><pre class="highlight code C++"><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>

<span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span></pre></div><div class="step step-level-1" step="196" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="304000" data-y="0" data-z="0"><h1 id="allocating-arrays">Allocating arrays</h1><pre class="highlight code C++"><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">25</span><span class="p">];</span>

<span class="k">delete</span><span class="p">[]</span> <span class="n">ptr</span><span class="p">;</span></pre></div><div class="step step-level-1" step="197" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="305600" data-y="0" data-z="0"><h1 id="initializing-allocation">Initializing Allocation</h1><pre class="highlight code C++"><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span> <span class="c1">//Initializes the value pointed to with 30
</span><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">30</span><span class="p">]();</span> <span class="c1">//Initializes a int array of 30 elements to 0</span></pre><ul><li>There is no way to initialize an array with anything other than 0.</li></ul></div><div class="step step-level-1" step="198" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="307200" data-y="0" data-z="0"><h1 id="avoid-naked-new-and-delete">Avoid naked "new" and "delete"</h1><ul><li>Avoid allocations in general code<blockquote><ul><li>Keep allocations buried inside the implementation of "well-behaved abstractions"</li></ul></blockquote></li><li>Makes code far less error-prone</li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>