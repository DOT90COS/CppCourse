<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="CSS/course.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="a-look-at-the-c-type-system">A look at the C++ type system</h1><img src="images/invisablesoftware.jpg"></img><div class="notes"><p>A good type system should stay out of the way of a programmer. It should allow a programmer to build their own types that are representative of the problem that they are trying to solve. It should allow these types to be used in the same way as built in types. C++ provides a rich set of types through the normal primitives as well as its standard library. C++ also provides ways to extend these types and to create user defined types which can be used in much the same way. This presentation is a look at the different types provided by C++.</p></div></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="std-is-fundamental">std::is_fundamental</h1><ul><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span></tt>: all types that can be used for math.<ul><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point</span></tt>: <tt>float, double, long double</tt></li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span></tt><ul><li><tt>bool</tt></li><li><strong>character types</strong>: <tt>char, signed char, unsigned char, char16_t, char32_t, wchar_t</tt></li><li><strong>signed integers</strong>: <tt>short int, int, long int, long long int</tt></li><li><strong>unsigned integers</strong>: <tt>unsigned short, unsigned int, unsigned long, unsigned long long</tt></li></ul></li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_void</span></tt>:</li><li><tt><span class="n">std</span><span class="o">::</span><span class="nl">is_null_pointer</span><span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span></tt></li></ul></li></ul><div class="notes"><p>We are using <tt>&lt;type_traits&gt;</tt> to talk about the C++ type system.</p><p><a href="http://en.cppreference.com/w/cpp/header/type_traits">http://en.cppreference.com/w/cpp/header/type_traits</a></p><p>Each of the <tt>std::is_*</tt> represents a type trait in the standard library that can be used to evaluate a type.
You will get more exposure to these in follow on assignments.</p></div></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="std-is-compound">std::is_compound</h1><ul><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_reference</span></tt>: reference types<ul><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span></tt>: lvalues to objects or functions</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_rvalue_reference</span></tt>: rvalues to objects or functions</li></ul></li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_pointer</span></tt>: pointer types to data or functions (not tied to objects)</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_member_pointer</span></tt>: pointer to data or function members of objects</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_array</span></tt>: array types</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_function</span></tt>: function types</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_enum</span></tt>: enumeration types</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_class</span></tt>: class types</li><li><tt><span class="n">std</span><span class="o">::</span><span class="n">is_union</span></tt>: a special class type</li></ul></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="machine-architectures-and-built-in-types">Machine Architectures and Built-in Types</h1><blockquote><p>There are four main data models in use today.</p></blockquote><ul><li><strong>32-bit systems</strong><ul><li>LP32 or 2/4/4 (int is 16-bit, long and pointer are 32-bit)<ul><li>Win16 API</li></ul></li><li>ILP32 or 4/4/4 (int, long, and pointer are 32-bit)<ul><li>Win32 API</li><li>Unix and Unix-like systems (Linux, Mac OS X)</li></ul></li></ul></li></ul><div class="notes"><p>The data model is an implementation choice of computer/software engineers about the sizes of fundamental types.</p><p>Other models do exists but are very rare. For example ILP64 (8/8/8: int, long, and pointer are 64-bit) do exists but
only appeared in some early model 64-bit Unix systems (e.g. Unicos on Cray).</p><p>The Win16 API is a legacy system that was used in Windows 1.0 to Windows 3.11, and for backwards compatibility is support to Windows 95/Windows ME.</p></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="id1">Machine Architectures and Built-in Types</h1><blockquote><p>There are four main data models in use today.</p></blockquote><ul><li><strong>64-bit systems</strong><ul><li>LLP64 or 4/4/8 (int and long are 32-bit, pointer is 64-bit)<ul><li>Win64 API</li></ul></li><li>LP64 or 4/8/8 (int is 32-bit, long and pointer are 64-bit)<ul><li>Unix and Unix-Like systems (Linux, Mac OS X)</li></ul></li></ul></li></ul><div class="notes"><p>This class will mostly be using ILP32 and LLP64 as we are on windows. I will work to show LP64 as well.</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="what-data-model-does-c-use">What data model does C++ use?</h1><ul><li>C++ compiles and runs on all of these systems.</li><li>Can the standard give us any guarantees that would be valid on all systems?</li><li>Is there any way to get portable types?</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="c-guarantees-bounded-types">C++ guarantees bounded types</h1><h2 id="signedness">Signedness</h2><ul><li><strong>signed</strong> - target type will have signed representation (this is the default).</li><li><strong>unsigned</strong> - target type will have unsigned representation.</li></ul><h2 id="size">Size</h2><p><tt><span class="kt">short</span> <span class="kt">int</span> <span class="o">&lt;=</span> <span class="kt">int</span> <span class="o">&lt;=</span> <span class="kt">long</span> <span class="kt">int</span> <span class="o">&lt;=</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span></tt></p><ul><li><strong>short</strong> - at least 16 bits.</li><li><strong>long</strong> - at least 32 bits.</li><li><strong>long long</strong> - at least 64 bits. (since C++11)</li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="a-portable-type-model">A portable type model</h1><p>What if your in a situation where you need to grantee that you type is a certain size on
all architectures.</p><pre class="highlight code C++"><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt; //since C++11</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt; //before C++11</span><span class="cp">
</span>
<span class="kt">uint32_t</span> <span class="n">is_a_32_bit_unsigned_int</span><span class="p">;</span>
<span class="kt">uint8_t</span>  <span class="n">is_a_8_bit_unsigned_char</span><span class="p">;</span>
<span class="kt">int64_t</span>  <span class="n">is_a_64_bit_signed_int</span><span class="p">;</span>
<span class="kt">uint_fast16_t</span> <span class="n">is_whatever_the_fastest_16bit_type_for_the_machine_is</span><span class="p">;</span></pre></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="c-floating-point-types">C++ Floating Point Types</h1><ul><li><strong>float</strong> - single precision. Usually IEEE-754 32 bit floating point type.</li><li><strong>double</strong> - double precision. Usually IEEE-754 64 bit floating point type.</li><li><strong>long double</strong> - extended precision.<ul><li>Doesn't have to map to types mandated by IEEE-754.</li><li>Usually 80-bit x87 floating point type on x86 and x86-64 architectures.</li></ul></li></ul><div class="notes"><p>x87 is a floating-point subset of the x86 architecture instruction set. Originated as an extension of the 8086 instruction set. This was back with coprocessors would work in tandem with x86 CPUs. The orginal x87 processor was 5 MHz. Todays processors are able to do these computation over 50,000 times faster.</p></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="user-defined-types">User defined types</h1><p>C++ allows programmers to create their own types. The standard library is a collection of user defined types.</p><ul><li>Classes</li><li>Structs (Really a type of class)</li><li>Enums</li><li>Unions</li></ul><div class="notes"><p>We will cover classes and structs in their own lecture.</p></div></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="c-style-un-scoped-enums">C Style Un-scoped Enums</h1><pre class="highlight code C++"><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">yellow</span><span class="p">};</span>
<span class="n">Color</span> <span class="n">light</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span>
<span class="k">switch</span><span class="p">(</span><span class="n">light</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="nl">red</span> <span class="p">:</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"red light</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">green</span> <span class="p">:</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"green light</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">yellow</span><span class="p">:</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">"yellow light</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="unscoped-enums-with-initializers">Unscoped Enums with initializers</h1><pre class="highlight code C++"><span class="k">enum</span> <span class="n">Foo</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">+</span><span class="n">c</span> <span class="p">};</span>
<span class="c1">//a=0, b=1, c=10, d=11, e=1, f=2, g=12</span></pre></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="problems-with-enums">Problems with enums</h1><ul><li>Polluted the global scope<ul><li>No two <tt>enums</tt> could have the same names for their members.</li><li>Collisions could happen when pulling in other peoples code.</li></ul></li></ul></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="c-11-and-later-enums">C++11 and later Enums</h1><pre class="highlight code C++"><span class="k">enum</span> <span class="nl">name</span><span class="p">:</span> <span class="n">type</span> <span class="p">{</span><span class="n">enumerator</span> <span class="o">=</span> <span class="k">constexpr</span><span class="p">,</span> <span class="n">enumerator</span> <span class="o">=</span> <span class="k">constexpr</span><span class="p">,</span> <span class="p">...</span> <span class="p">};</span>

<span class="c1">// or better yet.
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">name</span><span class="o">:</span> <span class="n">type</span> <span class="p">{</span><span class="n">enumerator</span> <span class="o">=</span> <span class="k">constexpr</span><span class="p">,</span> <span class="n">enumerator</span> <span class="o">=</span> <span class="k">constexpr</span><span class="p">,</span> <span class="p">...};</span></pre></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="c-11-enum-example">C++11 Enum Example</h1><pre class="highlight code C++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Light</span> <span class="o">:</span> <span class="kt">char</span> <span class="p">{</span><span class="n">red</span><span class="o">=</span><span class="sc">'R'</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="sc">'G'</span><span class="p">,</span> <span class="n">yellow</span><span class="o">=</span><span class="sc">'Y'</span><span class="p">};</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">{</span><span class="n">red</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">yellow</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">brown</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Color</span> <span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
    <span class="n">Light</span> <span class="n">light</span> <span class="o">=</span> <span class="n">Light</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="unions">Unions</h1><pre class="highlight code C++"><span class="k">typedef</span> <span class="k">union</span> <span class="n">ARGB</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">color</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">componentsTag</span>
    <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">a</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">b</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">g</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span><span class="n">components</span><span class="p">;</span>
<span class="p">}</span><span class="n">pixel</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pixel</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="mh">0x334455AA</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"R: 0x"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"G: 0x"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B: 0x"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A: 0x"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre><div class="notes"><p>Unions can also be useful to building a variant type of basic types. Unions can't hold complex types in pre C++11.
C++11 allows for one data member that can have a default constructor.</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="literals">Literals</h1><p>There are many more literals in C++ than C. In C++ you can even create your own literals.
C++ provides literals for:</p><ul><li>Integers</li><li>Floating Point</li><li>Character</li><li>String</li><li>nullptr (C++11)</li><li>user defined (C++11)</li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="integer-literals">Integer Literals</h1><ul><li><strong>decimal-literal</strong>: <tt>123432</tt> (a literal number)</li><li><strong>octal-literal</strong>: <tt>034532</tt></li><li><strong>hex-literal</strong>: <tt>0xDEADBEEF</tt></li><li><strong>binary-literal</strong>: <tt>0b1110010101101</tt> (C++14)</li><li><strong>integer suffix</strong><ul><li><strong>unsigned suffix</strong>: <tt>u</tt> or <tt>U</tt> (i.e. <tt>0xDEADBEEFU</tt> or <tt>123432u</tt>)</li><li><strong>long-suffix</strong>: <tt>l</tt> or <tt>L</tt> (i.e. <tt>0xDEADBEEFL</tt> will be <tt>0x00000000DEADBEEF</tt> on LP64)</li><li><strong>long-long-suffix</strong>: <tt>ll</tt> or <tt>LL</tt> (C++11)</li></ul></li><li>optionally single quotes (') may be inserted between the digits. These are ignored by the compiler. (C++14)</li></ul></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="floating-point-literals">Floating Point Literals</h1><ul><li><strong>digit-sequence</strong>: whole number without a decimal seperator, exponent not optional <tt>1e10</tt>, <tt>1e-5L</tt></li><li><strong>digit-sequence</strong>: <tt>1.e-1</tt> (in this case the exponent is optional)</li><li><strong>digit-sequence</strong>: <tt>3.14</tt>, <tt>1.42e100</tt></li><li><strong>hex-digit-sequence</strong>: <tt>0x1ffp10</tt> or <tt>0x1ff.p10</tt> or <tt>0x0.12fp-1</tt> exponent is never optional for hex-digit-sequences</li><li><strong>suffix</strong><ul><li>(no suffix) - defines <tt>double</tt></li><li><tt>f</tt> or <tt>F</tt> - defines <tt>float</tt></li><li><tt>l</tt> or <tt>L</tt> - defines <tt>long double</tt></li></ul></li></ul></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="character-literals">Character Literals</h1><ul><li><tt>'c-char'</tt> - <tt>char</tt></li><li><tt>u8'c-char'</tt> - UTF-8 <tt>char</tt></li><li><tt>u'c-char'</tt> - UCS-2 character - <tt>char16_t</tt></li><li><tt>U'c-char'</tt> - UCS-4 character - <tt>char32_t</tt></li><li><tt>L'c-char'</tt> - wide character - implementation-defined</li><li><tt>'c-char-sequence'</tt> : Can be combined with the above prefixes.</li></ul></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="character-literal-escape-sequences">Character Literal Escape Sequences</h1><ul><li><tt>\'</tt>: single quote</li><li><tt>\"</tt>: double quote</li><li><tt>\?</tt>: question mark</li><li><tt>\\</tt>: backslash</li><li><tt>\a</tt>: audible bell</li><li><tt>\b</tt>: backspace</li><li><tt>\f</tt>: form feed</li><li><tt>\n</tt>: new line</li><li><tt>\r</tt>: carriage return</li><li><tt>\t</tt>: horizontal tab</li><li><tt>\v</tt>: vertical tab</li><li><tt>\nnn</tt>: arbitrary octal value</li><li><tt>\Xnn</tt>: arbitrary hex value</li><li><tt>\Unnnn</tt>: Universal character name</li><li><tt>\Unnnnnnnn</tt>: universal character name</li></ul><div class="notes"><p>Of the octal escape sequences, 0 is the most useful as it represents the terminating null character in a null-terminated string.</p></div></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="string-literals">String Literals</h1><p>Mostly the same as character literals</p><ul><li><tt>"unescaped or escaped characters"</tt></li><li><tt>L"unescaped or escaped characters"</tt></li><li><tt>u8"unescaped or escaped characters"</tt> (C++11)</li><li><tt>u"unescaped or escaped characters"</tt> (C++11)</li><li><tt>U"unescaped or escaped characters"</tt> (C++11)</li><li><tt>R"delimiter(raw characters)delimiter"</tt> (C++11)</li></ul><pre class="highlight code C++"><span class="c1">//Raw String Examples
</span><span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="n">R</span><span class="s">"foo("</span><span class="k">this</span> <span class="n">is</span> <span class="n">a</span> <span class="n">raw</span> <span class="n">string</span><span class="s">"/"</span><span class="n">I</span> <span class="p">(</span><span class="n">can</span><span class="p">)</span> <span class="n">use</span> <span class="n">all</span> <span class="n">kinds</span> <span class="n">of</span> <span class="err">'</span><span class="n">characters</span><span class="err">'</span><span class="s">")foo"</span><span class="p">;</span></pre></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="nullptr">nullptr</h1><p>A literal that represent <tt>NULL</tt>.</p><p>Why would we want that we already have <tt>NULL</tt> and 0?</p><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//do something with a
</span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//do something with a
</span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//calls foo(int)
</span>    <span class="n">foo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="c1">//calls foo(int)
</span>    <span class="n">foo</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">//calls foo(char*)
</span><span class="p">}</span></pre><div class="notes"><p>TODO: Add more reason for nullptr here.</p></div></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="pointers-references-and-const-oh-my">Pointers, References, and <tt>const</tt> oh my!</h1><ul><li><strong>Pointers</strong>: Are used to hold memory addresses can be dereferences to access the thing at an address.</li><li><strong>References</strong>: Are syntactic sugar, so that code is easier to read and write.</li></ul><ol><li>A pointer can be re-assigned any number of times while a reference can not be re-seated after binding.</li><li>Pointers can point to nowhere, references always refer to an object. (must be initialized)</li><li>You can't take the address of a reference like you can a pointer.</li><li>There is no reference arithmetic.</li></ol></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="id2">Pointers, References, and <tt>const</tt> oh my!</h1><p><tt>const</tt> declares variables that can't be modified. Pay careful attention to applying const to pointers.</p><ul><li><tt>const int*</tt> is a pointer that can be re-assigned but points to constant data.</li><li><tt>int* const</tt> is a pointer that can't be re-assigned as it is const.</li><li><tt>const int* const</tt> is a pointer that is const and points to constant data.</li></ul><pre class="highlight code C++"><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0xCAFEF00D</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">//ERROR storing pointer to constant data in non-const pointer.
</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="n">ptr2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="n">ptr3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span> <span class="c1">//ERROR pointer is const and can't be modified.</span></pre></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="id3">Pointers, References, and <tt>const</tt> oh my!</h1><h2 id="example">Example</h2><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//This prints the value of fooptr below.
</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo is at"</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">foo</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mh">0xCAFEF00D</span>
  <span class="kt">int</span><span class="o">&amp;</span> <span class="n">fooref</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">fooptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>
  <span class="n">fooref</span> <span class="o">+=</span> <span class="mh">0xEE0</span><span class="p">;</span> <span class="c1">//foo is now 0xCAFEFEED
</span>  <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="constexpr-c-11">constexpr (C++11)</h1><p><em>Concept</em>: Value is not only constant but is also known at compile time!
<em>Reality</em>: You can't assume the results of a constexpr function are const, nor that they are known at compile time.</p><dl><dt><tt>constexpr</tt> can be applied to variables and functions.</dt><dd><ul><li>object</li><li>function</li><li>function templates</li></ul></dd></dl><pre class="highlight code C++"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">beef</span> <span class="o">=</span> <span class="mh">0xCAFEBEEF</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">beefref</span> <span class="o">=</span> <span class="n">beef</span><span class="p">;</span> <span class="c1">//bound to reference beef (can't be changed)
</span><span class="k">constexpr</span> <span class="kt">int</span><span class="o">*</span> <span class="n">beefptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">beefref</span><span class="p">;</span> <span class="c1">//because beefref is a reference it can be used like beef
</span><span class="k">static_assert</span><span class="p">(</span><span class="n">beef</span> <span class="o">==</span> <span class="n">beefref</span> <span class="o">&amp;&amp;</span> <span class="n">beef</span> <span class="o">==</span> <span class="o">*</span><span class="n">beefptr</span><span class="p">,</span> <span class="s">"These should all be equal here"</span><span class="p">);</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">square</span><span class="p">(</span><span class="mi">2</span><span class="p">)];</span> <span class="c1">//allowed because of constexpr</span></pre><p><tt>static_assert</tt> is a <strong>compile</strong> time assert that will output the message argument as an error if the assertion fails. <tt>static_assert</tt> must be given a boolean condition that is <tt>constexpr</tt>.</p></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="constexpr-objects-c-11">constexpr objects (C++11)</h1><ul><li>objects are in fact const</li><li>Values are known at translation<ul><li>Translation consists not just of compilation but also of linking.</li></ul></li><li>Because known at compilation time:<ul><li>Values can be placed in Read-only memory</li><li>Integral values that are const and known at compile time can be used where C++ requires integral constant expressions
* std::array, Template arguments, array sizes, etc...</li><li>Note that const does not offer the same guarantee as constexpr, because objects need not be initialized with values known at compile time.</li></ul></li></ul></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><pre class="highlight code C++"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
 <span class="kt">double</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">constexpr</span> <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">x_</span><span class="p">{</span><span class="n">x</span><span class="p">},</span> <span class="n">y_</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="p">{}</span>
  <span class="k">constexpr</span> <span class="n">doube</span> <span class="n">xValue</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">x_</span><span class="p">;}</span>
  <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">yValue</span><span class="p">()</span> <span class="k">const</span> <span class="n">no</span> <span class="n">except</span> <span class="p">{</span><span class="k">return</span> <span class="n">y_</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setX</span><span class="p">(</span><span class="kt">double</span> <span class="n">newX</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span><span class="n">x_</span><span class="o">=</span><span class="n">newX</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setY</span><span class="p">(</span><span class="kt">double</span> <span class="n">newY</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span><span class="n">y_</span><span class="o">=</span><span class="n">newY</span><span class="p">;}</span>
 <span class="p">};</span>

<span class="k">constexpr</span> <span class="n">Point</span> <span class="nf">p1</span><span class="p">(</span><span class="mf">9.4</span><span class="p">,</span> <span class="mf">27.7</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="n">Point</span> <span class="nf">p2</span><span class="p">(</span><span class="mf">28.8</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">);</span>

<span class="k">constexpr</span> <span class="nf">midpoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span>  <span class="p">{</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">xValue</span><span class="p">()</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="n">xValue</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">yValue</span><span class="p">()</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="n">yValue</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">Point</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span> <span class="c1">//THIS EXIST IN READ ONLY MEMORY!!!</span></pre></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="constexpr-functions-c-11">constexpr functions (C++11)</h1><ul><li>shall have exactly one return statement.</li><li>return type shall be a literal type. (not void)</li><li>parameters shall be literal types.</li><li>function body shall be a compound-statement of the form {return expression;}<ul><li>C++14 lifts this restriction</li><li>In C++11 you can get a little more bang utilizing "? :"  and recursion.</li></ul></li><li>Returns a constexpr result if the values of the arguments passed to constexpr are known at compile time.</li><li>If called with values that are not known acts as a normal function.</li></ul></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><pre class="highlight code C++"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>              <span class="c1">//OK
</span>
<span class="k">constexpr</span> <span class="kt">long</span> <span class="nf">long_max</span><span class="p">()</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">2147483647</span><span class="p">;</span> <span class="p">}</span>       <span class="c1">//OK
</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">abs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">//OK
</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="c1">//... do stuff     }       //ERROR: return type is void
</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">prev</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="o">--</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>              <span class="c1">//ERROR: Use of decrement works with clang
</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="c1">//ERROR: C++11 doesn't allow this but C++14 does!
</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">n</span> <span class="p">)</span> <span class="n">r</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="runtime-sized-arrays-c-14">Runtime-Sized Arrays C++14</h1><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//This is ok in C++14
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="decltype">decltype</h1><p><tt>decltype(e)</tt> deduce and returns the type of its argument e.</p><ul><li>If the expression e refers to a variable in local or namespace scope, a static member variable or a function parameter, the the result is that variable's or parameter's declared type.</li><li>If <tt>e</tt> is a function call or an overloaded operator invocation, <tt>decltype(e)</tt> denotes the declared return type of that function.</li><li>Otherwise, if e is an lvalue, <tt>decltype(e)</tt> is <tt>T&amp;</tt>, where <tt>T</tt> is the type of <tt>e</tt>; if e is an rvalue; the result is <tt>T</tt>.</li></ul><pre class="highlight code C++"><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//c has type int
</span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//d has type int
</span><span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span> <span class="c1">//e has type int, the type of the entity named by c
</span><span class="k">decltype</span><span class="p">((</span><span class="n">c</span><span class="p">))</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//f has type int&amp;, because (c) is an lvalue
</span><span class="k">decltype</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">g</span><span class="p">;</span> <span class="c1">//g has type int, because 0 is an rvalue</span></pre><div class="notes"><p>These semantics were designed to fulfill the needs of generic library writers, while at the same time being intuitive for novice programmers, because the return type of decltype always matches the type of the object or function exactly as declared in the source code. More formally, Rule 1 applies to unparenthesized id-expressions and class member access expressions. For function calls, the deduced type is the return type of the statically chosen function, as determined by the rules for overload resolution.</p></div></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="auto-c-11">auto (C++11)</h1><p><tt>auto</tt> is a generic type that use type deduction to figure out the type at compile time. Auto has the following features.</p><ul><li>Must be initialized.</li><li>Adapts well to refactoring.</li><li>Efficient by default (no implicit conversions)</li><li>Generally simpler and less typing.</li><li>Defaults to by value.</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span> <span class="c1">// standard function pointer.
</span>    <span class="k">auto</span> <span class="n">auto_fp</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// function to pointer conversion
</span>    <span class="k">const</span> <span class="k">auto</span> <span class="n">auto_fp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span> <span class="c1">// equivalent to auto_fp
</span>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">auto_fr</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// reference
</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bar</span><span class="p">;</span>
    <span class="n">auto_fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bar</span><span class="p">;</span>
    <span class="n">auto_fp2</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">//ERROR would work if not const.
</span>    <span class="n">auto_fr</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">//COMPILATION ERROR
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="type-casting">Type Casting</h1><p>C-style casts actually represent different types of cast in one operator</p><ul><li>static-cast - usually safe</li><li>const-cast - <strong>dangerous</strong></li><li>reinterpret-cast - <strong>dangerous</strong></li></ul><p>C++ separates these all out for safety reasons. C++ also adds one more type of cast.</p><ul><li>dynamic-cast</li></ul></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><h1 id="widening-conversions-promotion">Widening Conversions (promotion)</h1><p>These are safe to do because there is no potential for a loss of data. Because these are safe, the compiler will
preform them silently and not issue any warnings.</p><img src="images/widening_conversion.png"></img></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="narrowing-conversions-coercion">Narrowing Conversions (coercion)</h1><p>These are the opposite of a widening conversion. Because they are a cast from a larger type to a smaller one there
is a possibility for data loss, making the conversion potentially unsafe. If your sure that the conversion is ok and there will be no loss of data, use an explicit cast to get rid of the compiler warning.</p><pre class="highlight code C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">INT_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//integer overflow
</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mf">1.9f</span><span class="p">;</span> <span class="c1">//possible loss of data</span></pre><div class="notes"><p>I had to increase the warning level to 4 in visual studio to get these warning to show up.</p></div></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><h1 id="static-cast-new-type-expression">static_cast&lt;new_type&gt;(expression);</h1><p>This is allowed when there is a valid conversion in the language, or an appropriate constructor that makes it possible. The danger with static cast is casting down between inherited classes and narrowing conversions.</p><ul><li>static_cast are checked at <strong>compile</strong> time only</li><li>static_cast return an error when trying to cast between things that are incompatible</li><li>static_cast can be used to cast between pointer to base and pointer to derived<ul><li>static_cast can't tell if it is safe at runtime.</li><li>dynamic_cast should be used to these situations to do runtime checks to see if the conversion is safe.</li></ul></li></ul><pre class="highlight code C++"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">big</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
<span class="kt">short</span> <span class="n">a</span> <span class="o">=</span> <span class="n">big</span><span class="p">;</span> <span class="c1">//conversion from 'int' to 'short', possible loss of data
</span><span class="kt">short</span> <span class="n">b</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">big</span><span class="p">);</span> <span class="c1">//no error</span></pre></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><h1 id="const-cast-new-type-expression">const_cast&lt;new_type&gt;(expression);</h1><p>Usually a sign of a bad design and shouldn't be used in new projects. The purpose of const is to keep a developer from modifying the argument. const_cast removes this restriction and breaks promises to a user that you wouldn't modify the data.</p><ul><li>can remove const or volatile modifiers</li><li>only really helpful with legacy APIs that are not const correct.
* APIs without a const interface that don't modify anything.</li></ul><pre class="highlight code C++"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//a and b == 0xDEADBEF0;</span></pre></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><h1 id="reinterpret-cast-new-type-expression">reinterpret_cast&lt;new_type&gt;(expression);</h1><p>This is also usually a sign of bad code.</p><p>Converts between types by reinterpreting the underlying bit pattern.</p><ul><li>Does not compile to any CPU instructions<ul><li>Simply instructs compiler to teat a series of bytes as something else.</li></ul></li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">reinterpret_Cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\x7'</span><span class="p">)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This system is little-endian</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="k">else</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This system is big-endian</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span></pre></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="64000" data-y="0" data-z="0"><h1 id="smart-pointers">Smart Pointers!</h1><p>Smart pointers are a better way to utilize memory in C++. They overcome many of the problems with normal pointers and better express the meaning of a particular pointer. It is still valid to pass pointers in C++ but this conveys nothing about ownership. The smart pointers that we will be discussing were added to the standard in C++11.</p><ul><li>std::share_ptr&lt;type_pointed_too&gt;(pointer);</li><li>std::weak_ptr&lt;type_pointed_too&gt;(pointer);</li><li>std::unique_ptr&lt;type_pointed_too&gt;(pointer);</li></ul><div class="notes"><p>All of these types are a part of the standard library.</p></div></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65600" data-y="0" data-z="0"><h1 id="problems-found-with-normal-pointers">Problems found with normal pointers</h1><ul><li>Knowing who <strong>owns</strong> the pointer, i.e. who is responsible for freeing the memory.</li><li>Forgetting to free the memory.</li><li>Freeing the memory more than once.</li><li>Not initializing memory.</li></ul></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67200" data-y="0" data-z="0"><h1 id="std-shared-ptr-type">std::shared_ptr&lt;type&gt;</h1><h2 id="multiple-people-own-me">Multiple people own me!</h2><ul><li>Shared pointer introduces a small cost to do reference counting.<blockquote><ul><li>It keeps track of the number of users</li><li>When all users are done with it, it frees the memory.</li></ul></blockquote></li><li>Can be created with make_shared&lt;type&gt;();</li></ul><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">bar</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a number: "</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
   <span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre><div class="notes"><p>One important thing to note is that there are no news or deletes in this code. There is nothing that needs to be reviewed to find all cases that we may need to free our dynamic memory. It is all handled by the shared_ptr.</p></div></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="68800" data-y="0" data-z="0"><h1 id="std-unique-ptr-type">std::unique_ptr&lt;type&gt;</h1><h2 id="only-one-can-own-me">Only one can own me!</h2><ul><li>Only one indirection compared to a raw pointer. (almost no overhead)</li><li>Can not be copied or assigned.</li><li>Can only be moved (meaning it is fast and there is only one copy).</li><li>std::move leaves the state of the object moved as undefined.<ul><li>testing with unique_ptr shows that the default deleter will set the moved from unique_ptr to nullptr.</li></ul></li></ul><pre class="highlight code C++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">bar</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a number: "</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
   <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>

   <span class="c1">//bar is nullptr
</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="70400" data-y="0" data-z="0"><h1 id="std-weak-ptr-type">std::weak_ptr&lt;type&gt;</h1><h2 id="nobody-owns-me-yet">Nobody owns me... yet</h2><ul><li>weak_ptr can be used to hold a weak reference to a shared_ptr.<ul><li>They don't increase the ref count of the shared_ptr</li><li>The shared_ptr may be free'd even while a weak_ptr exists.</li><li>weak_ptr must be promoted to a share_ptr in order to actually use the data.</li></ul></li></ul><pre class="highlight code C++"><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gw</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">spt</span> <span class="o">=</span> <span class="n">gw</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Has to be copied into a shared_ptr before usage
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">spt</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"gw is expired</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
        <span class="n">gw</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
        <span class="n">f</span><span class="p">();</span> <span class="c1">// 42
</span>    <span class="p">}</span>
    <span class="n">f</span><span class="p">();</span> <span class="c1">// gw is expired
</span><span class="p">}</span></pre></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>