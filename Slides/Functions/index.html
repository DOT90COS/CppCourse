<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="CSS/course.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="functions-lambdas-and-std-function">Functions, Lambdas, and std::function</h1><img src="images\\quote-the-only-way-to-learn-a-new-programming-language-is-by-writing-programs-in-it.jpg"></img><div class="notes"><p>TODO...</p></div></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="functions-in-c">Functions in C++</h1><p>Functions in C++ are very similar to functions in C and other languages.</p><ul><li>Can be overloaded</li><li>Parameters can be defaulted</li><li>Can be inlined at the choice of the compiler.</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// declaration
</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">arg2</span><span class="p">)</span> <span class="c1">// definition
</span><span class="p">{</span>
    <span class="c1">//does stuff and returns an int.
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="function-overloading">Function Overloading</h1><p>Functions can have the same name so long as the signature is different</p><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span> <span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">//error impossible to differentiate between a call to foo() and a call to foo();
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">double</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//error impossible to differentiate between a call to foo(2.0);
</span><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//int's are by default signed and therefore this is the same function as above.</span></pre></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="default-parameters">Default Parameters</h1><p>In the declaration you can specify a default.</p><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">foo</span><span class="p">();</span> <span class="c1">//prints 4
</span>   <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//prints 1
</span><span class="p">}</span></pre></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="default-parameters-with-overloading">Default Parameters with overloading</h1><p>The compiler must be able to tell the difference between two functions. Defaulting parameters can affect this.</p><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//prints 1
</span>   <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//???
</span>   <span class="n">foo</span><span class="p">();</span> <span class="c1">//prints 2
</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="inline">inline</h1><ul><li>serves as a indicator to the optimizer.</li><li>non binding.</li><li>compilers are free to inline any function not marked inline.</li><li>compilers are free to use a function calls for functions marked inline.</li><li>should be placed in a header file.</li><li>increases the size of the code.<ul><li>for very small functions in-lining may reduce size.</li></ul></li><li>often the compiler will be able to apply context specific optimizations to code it couldn't do otherwise.</li></ul><pre class="highlight code C++"><span class="c1">//HEADER FILE
</span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;}</span> <span class="c1">//explicit inlining
</span><span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;}</span> <span class="c1">//implicit inlining because this is in a header.</span></pre></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="use-of-auto">Use of auto</h1><p>There are currently proposals for using auto for function parameters (i.e. that may be in C++17)
Currently you can use auto for the return type.</p><ul><li>Auto can be used as parameters to lambdas in C++14</li><li>Auto is the default return type for a lambda.</li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="trailing-return-type">trailing return type</h1><pre class="highlight code C++"><span class="c1">//JUST BECAUSE YOU CAN DO THIS DOESN'T MEAN YOU SHOULD!!!
</span>
<span class="k">auto</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">main</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="calling-conventions">Calling conventions</h1><pre class="highlight code C++"><span class="c1">//by value
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">//by reference
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">//by const reference
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">//by pointer
</span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span></pre><div class="notes"><p>Talk about why const ref isn't that valuable for fundamental types but for objects it is a good improvement.</p></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="id1">Calling Conventions</h1><h2 id="from-cppcoreguidelines">From CppCoreGuidelines</h2><img src="images/param-passing-advanced.png" height="500"></img></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="where-to-define-variables">Where to define variables</h1><p>C89/90 Requires programmers to declare variables "at the top of the function"</p><p><strong>Why you shouldn't do this</strong></p><ul><li>Encourages variable reuse.</li><li>Hard to initialize with reasonable values.</li><li>Item 26 in the Effective C++ says not to do this.</li><li>Often you pay for construction twice. (once to initialize and once to give it a meaningful value)</li><li>Often you may not need to pay for the construction. (return or exception thrown before use)</li></ul></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="lambda">Lambda</h1><pre class="highlight code C++"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithms&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">uint</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mh">0xDEADBEEF</span><span class="p">,</span> <span class="p">...</span> <span class="p">};</span> <span class="c1">//a bunch of "data";
</span>
    <span class="c1">//LAMBDA TIME!
</span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">uint</span> <span class="n">a</span><span class="p">,</span> <span class="n">uint</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;});</span>

    <span class="c1">//do stuff with your sorted data!
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="lambda-captures">Lambda Captures</h1><p>I want to use something that is in my local scope...</p><ul><li><tt>[ ]</tt> capture nothing</li><li><tt>[&amp;]</tt> capture anything I use by reference</li><li><tt>[=]</tt> capture anything I use by value</li><li><tt>[x]</tt> capture x by value (value is the default)</li><li><tt>[&amp;y]</tt> capture y by reference</li><li><tt>[x, &amp;y]</tt> capture x by value and y by reference</li><li>By value captures are treated as r-values. (unless lambda is declared mutable.)</li></ul><div class="notes"><p>Specifically ask, "Is there any reason the ones with the variables would be preferable to 2 and 3?".</p><p>The Lambdas project under the Functions solution can show some examples of these in use, but
the next slide covers some stuff that is in that file so tell them you will show examples by wait for now.</p></div></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="lambda-gotcha">Lambda Gotcha?</h1><p>What does this print?</p><pre class="highlight code C++"><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//important to note this is static (i.e. won't get cleaned up off the stack)
</span>  <span class="k">static</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">return</span> <span class="p">[](){</span><span class="k">return</span> <span class="mi">0</span><span class="p">;};</span> <span class="c1">//return type is auto by default.
</span>    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](){</span><span class="k">return</span> <span class="n">y</span><span class="o">++</span><span class="p">;};</span> <span class="c1">//capture by value
</span>    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">return</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](){</span><span class="k">return</span> <span class="n">y</span><span class="o">++</span><span class="p">;};</span> <span class="c1">//capture by reference
</span>
    <span class="k">default</span><span class="o">:</span> <span class="k">return</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">x</span><span class="p">](){</span><span class="k">return</span> <span class="n">z</span><span class="o">++</span><span class="p">;};</span> <span class="c1">//capture named by reference
</span>  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></pre><div class="notes"><p>static variables can't be captured... It is using the real static variables in the lambda.
<tt>[](){return y++}</tt> would to the same thing.</p></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="storage-classes">Storage Classes</h1><ul><li><strong>Automatic</strong>: All variables defined in a block that aren't one of the others.</li><li><strong>extern</strong>: An object or variable in another translation unit.</li><li><strong>static</strong>: Persist for the lifetime of the program, can be global, namespace, class or local scope<ul><li>static variable retain their state</li></ul></li><li><strong>thread_local</strong>: A variable that is only accessible on the thread which it is created.</li></ul><div class="notes"><p>all lambda captures must be automatic.</p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="include-functional">#include &lt;functional&gt;</h1><h2 id="lots-of-neat-things-here">Lots of neat things here.</h2><ul><li><tt>std::bind</tt> - creates a function wrapper and lets you "bind" parameters to certain values.</li><li><tt>std::function</tt> - creates a polymorphic function pointer.</li><li>Function objects for doing stuff<ul><li>Arithmetic <tt>plus</tt>, <tt>minus</tt>, <tt>multiplies</tt>, <tt>divides</tt>, <tt>modulus</tt>, <tt>negate</tt></li><li>Comparisons <tt>equal_to</tt>, <tt>not_equal_to</tt>, <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, <tt>less_equal</tt></li><li>Logical <tt>logical_and</tt>, <tt>logical_or</tt>, <tt>logical_not</tt></li><li>Bitwise <tt>bit_and</tt>, <tt>bit_or</tt>, <tt>bit_xor</tt>, <tt>bit_not</tt></li></ul></li></ul><div class="notes"><p>Not really going to talk about the funciton object just know they are there and pretty cool.</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="std-bind">std::bind</h1><pre class="highlight code C++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>

<span class="c1">// std::multiplies&lt;int&gt;(a, b) takes two arguments. The transform function can only take one.
// Here we are using multiplies to double each number.
</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">being</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span></pre><div class="notes"><p>what are some other ways we can get the same results?</p><dl><dt>[](int a){</dt><dd><p>return std::multiplies&lt;int&gt;(2, a); }</p></dd></dl><p>Because of this there is really only a difference before C++14. This is because lambdas prior to C++14 are not polymorphic while bind is. I.E. bind is templated and can bind templated parameters so that the bind can be used with different types.</p></div></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="std-function">std::function</h1><ul><li>Can hold more than functions<ul><li>functors (You don't know what these are yet, although you have used them :) )</li><li>lambdas (really a special case of functors)</li></ul></li><li>Functions don't have the have the exact same signature... Just need to be compatible.</li></ul><pre class="highlight code C++"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">foo_functor</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">short</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">fn</span> <span class="o">=</span> <span class="n">foo_functor</span><span class="p">();</span></pre></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>